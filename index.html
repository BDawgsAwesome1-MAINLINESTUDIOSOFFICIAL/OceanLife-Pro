<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OceanLife Pro - Photorealistic Beach Simulation</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
margin: 0;
overflow: hidden;
background: linear-gradient(135deg, #87CEEB 0%, #E0F6FF 100%);
font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
color: white;
-webkit-font-smoothing: antialiased;
}

/* Loading Screen */
#loading-screen {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: linear-gradient(135deg, #0a4d6e 0%, #1a7fa0 100%);
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
z-index: 10000;
transition: opacity 0.8s ease;
}

.loader-container {
text-align: center;
}

.wave-loader {
width: 100px;
height: 100px;
margin: 0 auto 30px;
position: relative;
}

.wave {
position: absolute;
width: 100%;
height: 100%;
border-radius: 50%;
border: 3px solid rgba(255, 255, 255, 0.3);
animation: wave-pulse 2s ease-in-out infinite;
}

.wave:nth-child(2) { animation-delay: 0.5s; }
.wave:nth-child(3) { animation-delay: 1s; }

@keyframes wave-pulse {
0% {
transform: scale(0.3);
opacity: 1;
}
100% {
transform: scale(1.5);
opacity: 0;
}
}

.loading-text {
font-size: 24px;
color: white;
margin-bottom: 10px;
font-weight: 600;
}

.loading-subtext {
font-size: 14px;
color: rgba(255, 255, 255, 0.7);
margin-top: 10px;
}

.loading-tip {
font-size: 12px;
color: rgba(255, 255, 255, 0.5);
margin-top: 24px;
max-width: 280px;
text-align: center;
font-style: italic;
}

.progress-bar {
width: 300px;
height: 4px;
background: rgba(255, 255, 255, 0.2);
border-radius: 2px;
overflow: hidden;
margin: 20px auto;
}

.progress-fill {
height: 100%;
background: linear-gradient(90deg, #00d4ff, #0af);
width: 0%;
transition: width 0.3s ease;
box-shadow: 0 0 10px rgba(0, 200, 255, 0.5);
}

/* Main UI */
#control-panel {
position: absolute;
top: 20px;
left: 20px;
background: rgba(10, 25, 40, 0.92);
padding: 25px;
border-radius: 20px;
backdrop-filter: blur(20px);
border: 1px solid rgba(255, 255, 255, 0.18);
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
max-width: 380px;
max-height: 90vh;
overflow-y: auto;
transition: all 0.3s ease;
}

#control-panel.collapsed {
transform: translateX(-340px);
}

.panel-toggle {
position: absolute;
right: -40px;
top: 20px;
width: 40px;
height: 50px;
background: rgba(10, 25, 40, 0.92);
border: 1px solid rgba(255, 255, 255, 0.18);
border-left: none;
border-radius: 0 10px 10px 0;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
backdrop-filter: blur(20px);
transition: all 0.3s ease;
}

.panel-toggle:hover {
background: rgba(0, 168, 255, 0.3);
}

.panel-toggle::before {
content: '‚óÄ';
color: white;
font-size: 16px;
}

#control-panel.collapsed .panel-toggle::before {
content: '‚ñ∂';
}

#control-panel::-webkit-scrollbar { width: 8px; }
#control-panel::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 4px; }
#control-panel::-webkit-scrollbar-thumb { background: linear-gradient(180deg, #00d4ff, #0066cc); border-radius: 4px; }

h1 {
margin: 0 0 8px 0;
font-size: 28px;
font-weight: 700;
background: linear-gradient(135deg, #00d4ff 0%, #0af 50%, #fff 100%);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
}

.subtitle {
font-size: 12px;
color: rgba(255, 255, 255, 0.6);
margin-bottom: 20px;
}

.section {
margin-bottom: 25px;
padding-bottom: 20px;
border-bottom: 1px solid rgba(255, 255, 255, 0.08);
}

.section:last-child { border-bottom: none; margin-bottom: 0; }

.section-title {
font-size: 13px;
color: #00d4ff;
text-transform: uppercase;
letter-spacing: 1.5px;
margin-bottom: 15px;
font-weight: 700;
display: flex;
align-items: center;
gap: 8px;
}

.control-group { margin-bottom: 15px; }

label {
display: block;
font-size: 13px;
color: rgba(255, 255, 255, 0.8);
margin-bottom: 8px;
font-weight: 500;
}

.value-display {
float: right;
color: #00d4ff;
font-weight: 700;
font-size: 12px;
}

input[type="range"] {
width: 100%;
height: 6px;
background: linear-gradient(90deg, rgba(0, 200, 255, 0.2), rgba(0, 200, 255, 0.4));
border-radius: 3px;
outline: none;
-webkit-appearance: none;
}

input[type="range"]::-webkit-slider-thumb {
-webkit-appearance: none;
width: 18px;
height: 18px;
background: linear-gradient(135deg, #00d4ff, #0066cc);
border-radius: 50%;
cursor: pointer;
box-shadow: 0 0 0 3px rgba(0, 200, 255, 0.3);
}

input[type="range"]::-moz-range-thumb {
width: 18px;
height: 18px;
background: linear-gradient(135deg, #00d4ff, #0066cc);
border-radius: 50%;
cursor: pointer;
border: none;
box-shadow: 0 0 0 3px rgba(0, 200, 255, 0.3);
}

button {
width: 100%;
background: linear-gradient(135deg, #0088ff 0%, #0066cc 100%);
border: none;
padding: 14px 20px;
color: white;
font-weight: 600;
border-radius: 12px;
cursor: pointer;
margin-bottom: 10px;
transition: all 0.3s ease;
font-size: 13px;
text-transform: uppercase;
letter-spacing: 1px;
box-shadow: 0 4px 15px rgba(0, 136, 255, 0.3);
}

button:hover {
transform: translateY(-2px);
box-shadow: 0 6px 25px rgba(0, 136, 255, 0.5);
}

button.active {
background: linear-gradient(135deg, #ff4757 0%, #cc0033 100%);
box-shadow: 0 4px 15px rgba(255, 71, 87, 0.4);
}

button.secondary {
background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
border: 1px solid rgba(255, 255, 255, 0.1);
}

.button-group {
display: grid;
grid-template-columns: 1fr 1fr;
gap: 10px;
margin-bottom: 10px;
}

.button-group button {
margin-bottom: 0;
font-size: 11px;
padding: 12px;
}

select {
width: 100%;
background: rgba(255, 255, 255, 0.08);
border: 1px solid rgba(255, 255, 255, 0.15);
color: white;
padding: 12px;
border-radius: 10px;
font-size: 13px;
cursor: pointer;
outline: none;
}

select option { background: #0a1928; color: white; }

.checkbox-container {
display: flex;
align-items: center;
margin-bottom: 12px;
cursor: pointer;
padding: 10px;
border-radius: 8px;
transition: all 0.2s ease;
}

.checkbox-container:hover { background: rgba(255, 255, 255, 0.05); }

.checkbox-container input[type="checkbox"] {
width: 20px;
height: 20px;
margin-right: 12px;
cursor: pointer;
accent-color: #00d4ff;
}

.checkbox-container label {
margin: 0;
cursor: pointer;
font-size: 13px;
}

/* Stats Panel */
#stats {
position: absolute;
top: 20px;
right: 20px;
background: rgba(10, 25, 40, 0.92);
padding: 20px;
border-radius: 16px;
font-family: 'Monaco', monospace;
font-size: 12px;
line-height: 1.8;
border: 1px solid rgba(255, 255, 255, 0.18);
min-width: 240px;
backdrop-filter: blur(20px);
}

.stat-line {
display: flex;
justify-content: space-between;
margin: 4px 0;
}

.stat-label { color: rgba(255, 255, 255, 0.7); }
.stat-value { color: #00ff88; font-weight: 700; }
.stat-title { font-size: 14px; font-weight: 700; margin-bottom: 10px; color: #00d4ff; }

/* Credits */
#credits {
position: absolute;
bottom: 20px;
left: 50%;
transform: translateX(-50%);
background: rgba(10, 25, 40, 0.85);
padding: 15px 30px;
border-radius: 12px;
border: 1px solid rgba(255, 255, 255, 0.15);
backdrop-filter: blur(20px);
text-align: center;
font-size: 12px;
color: rgba(255, 255, 255, 0.8);
}

#credits strong { color: #00d4ff; }

/* Notification */
.notification {
position: fixed;
top: 30px;
left: 50%;
transform: translateX(-50%);
background: linear-gradient(135deg, rgba(0, 200, 255, 0.95), rgba(0, 136, 255, 0.95));
color: white;
padding: 18px 30px;
border-radius: 12px;
box-shadow: 0 8px 30px rgba(0, 200, 255, 0.5);
z-index: 10001;
animation: notifSlide 0.4s ease;
font-weight: 600;
font-size: 14px;
}

@keyframes notifSlide {
from { transform: translateX(-50%) translateY(-100px); opacity: 0; }
to { transform: translateX(-50%) translateY(0); opacity: 1; }
}

.mode-badge {
display: inline-block;
background: linear-gradient(135deg, #ffd700, #ffed4e);
color: #000;
padding: 4px 12px;
border-radius: 20px;
font-size: 10px;
font-weight: 800;
margin-left: 10px;
}

/* Context Menu */
#context-menu {
position: absolute;
display: none;
background: rgba(15, 30, 45, 0.98);
border: 1px solid rgba(0, 200, 255, 0.4);
border-radius: 12px;
box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
padding: 8px 0;
z-index: 2000;
min-width: 220px;
backdrop-filter: blur(20px);
}

.menu-item {
padding: 14px 20px;
color: white;
cursor: pointer;
font-size: 13px;
transition: all 0.2s;
display: flex;
align-items: center;
}

.menu-item:hover {
background: linear-gradient(90deg, rgba(0, 200, 255, 0.3), transparent);
color: #00d4ff;
}

.menu-icon {
margin-right: 12px;
font-size: 18px;
width: 24px;
text-align: center;
}

.menu-divider {
height: 1px;
background: rgba(255, 255, 255, 0.1);
margin: 8px 12px;
}
</style>
</head>
<body>

<!-- Loading Screen -->
<div id="loading-screen">
<div class="loader-container">
<div class="wave-loader">
<div class="wave"></div>
<div class="wave"></div>
<div class="wave"></div>
</div>
<div class="loading-text">üèñÔ∏è OceanLife Pro</div>
<div class="loading-subtext">Photorealistic Beach Simulation</div>
<div class="progress-bar">
<div class="progress-fill" id="progress"></div>
</div>
<div class="loading-subtext" id="load-status">Starting...</div>
<div class="loading-tip" id="loading-tip"></div>
</div>
</div>

<!-- Performance Stats -->
<div id="stats">
<div class="stat-title">‚ö° Performance</div>
<div class="stat-line"><span class="stat-label">FPS:</span> <span class="stat-value" id="fps">60</span></div>
<div class="stat-line"><span class="stat-label">Mode:</span> <span class="stat-value" id="currentMode">ULTRA</span></div>
<div class="stat-line"><span class="stat-label">People:</span> <span class="stat-value" id="peopleCount">8</span></div>
<div class="stat-line"><span class="stat-label">Particles:</span> <span class="stat-value" id="particleCount">0</span></div>
<div class="stat-line"><span class="stat-label">Water:</span> <span class="stat-value" id="waterType">Mesh</span></div>
</div>

<!-- Main Control Panel -->
<div id="control-panel">
<div class="panel-toggle" onclick="togglePanel()"></div>

<h1>üèñÔ∏è OceanLife Pro</h1>
<div class="subtitle">Photorealistic Beach Simulation v3.0</div>

<div class="section">
<div class="section-title">üé¨ Rendering Mode</div>
<select id="renderMode" onchange="switchRenderMode()">
<option value="ultra">üåü Ultra Photorealistic (High-End)</option>
<option value="particle">üíß Particle Physics (Low-End)</option>
<option value="hybrid">‚ö° Hybrid Mode</option>
</select>
<div style="font-size: 11px; color: rgba(255,255,255,0.5); margin-top: 8px;">
Use Particle mode for older devices
</div>
</div>

<div class="section">
<div class="section-title">üåä Water Physics</div>

<div class="control-group">
<label>Wave Intensity <span class="value-display" id="waveIntensityVal">1.2</span></label>
<input type="range" id="waveIntensity" min="0.1" max="3.0" value="1.2" step="0.1" oninput="updateWaveIntensity(this.value)">
</div>

<div class="control-group">
<label>Wave Speed <span class="value-display" id="waveSpeedVal">1.0x</span></label>
<input type="range" id="waveSpeed" min="0.3" max="3.0" value="1.0" step="0.1" oninput="updateWaveSpeed(this.value)">
</div>
</div>

<div class="section">
<div class="section-title">üë• People Settings</div>

<div class="control-group">
<label>Number of People <span class="value-display" id="peopleCountVal">8</span></label>
<input type="range" id="peopleSlider" min="0" max="20" value="8" step="1" oninput="updatePeopleCount(this.value)">
</div>

<div class="checkbox-container">
<input type="checkbox" id="animatePeople" checked onchange="toggleAnimation(this.checked)">
<label for="animatePeople">Animate People</label>
</div>

<div class="checkbox-container">
<input type="checkbox" id="showSplashes" checked onchange="toggleSplashes(this.checked)">
<label for="showSplashes">Water Splashes</label>
</div>
</div>

<div class="section">
<div class="section-title">‚òÄÔ∏è Environment</div>

<div class="control-group">
<label>Time of Day <span class="value-display" id="timeVal">Noon</span></label>
<input type="range" id="timeOfDay" min="0" max="24" value="12" step="0.5" oninput="updateTimeOfDay(this.value)">
</div>

<div class="control-group">
<label>Sun Intensity <span class="value-display" id="sunVal">1.5</span></label>
<input type="range" id="sunIntensity" min="0.5" max="3" value="1.5" step="0.1" oninput="updateSunIntensity(this.value)">
</div>
</div>

<div class="section">
<div class="section-title">üéÆ Quick Actions</div>

<button onclick="createBigWave()">üåä Generate Big Wave</button>
<button onclick="addPerson()">‚ûï Add Person</button>

<div class="button-group">
<button class="secondary" onclick="resetScene()">‚Üª Reset</button>
<button class="secondary" onclick="randomizeScene()">üé≤ Random</button>
</div>
</div>

<div class="section">
<div class="section-title">üé¨ Presets</div>

<button class="secondary" onclick="loadPreset('morning')">üåÖ Morning</button>
<button class="secondary" onclick="loadPreset('noon')">‚òÄÔ∏è Noon</button>
<button class="secondary" onclick="loadPreset('sunset')">üåá Sunset</button>
<button class="secondary" onclick="loadPreset('storm')">‚õàÔ∏è Storm</button>
</div>
</div>

<!-- Credits -->
<div id="credits">
<strong>OceanLife Pro</strong> ‚Äî Drag to orbit ¬∑ Right-click for menu ¬∑ Built with Three.js
</div>

<!-- Context Menu -->
<div id="context-menu">
<div class="menu-item" onclick="addPersonAt()">
<span class="menu-icon">üë§</span> Add Person Here
</div>
<div class="menu-item" onclick="createWaveAt()">
<span class="menu-icon">üåä</span> Create Wave
</div>
<div class="menu-divider"></div>
<div class="menu-item" onclick="spawnBeachBall()">
<span class="menu-icon">üèê</span> Beach Ball
</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
console.log('üèñÔ∏è OceanLife Pro - Initializing...');

// ==========================================
// GLOBAL STATE
// ==========================================

const CONFIG = {
renderMode: 'ultra',
waveIntensity: 1.2,
waveSpeed: 1.0,
peopleCount: 8,
timeOfDay: 12,
sunIntensity: 1.5,
animatePeople: true,
showSplashes: true
};

let scene, camera, renderer, controls;
let ocean, people = [], beachObjects = [];
let particleSystem;
let waterParticles = [];
let sunLight, skyLight, ambientLight;
let birdsSystem;
let skyMesh;

// ==========================================
// SCENE SETUP
// ==========================================

function initScene() {
console.log('Initializing scene...');

scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);

camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
camera.position.set(0, 25, 80);

renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
renderer.outputEncoding = THREE.sRGBEncoding;
document.body.appendChild(renderer.domElement);

controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.maxPolarAngle = Math.PI / 2.1;
controls.minDistance = 20;
controls.maxDistance = 200;

console.log('Scene initialized ‚úì');
}

// ==========================================
// LIGHTING
// ==========================================

function setupLighting() {
console.log('Setting up lighting...');

ambientLight = new THREE.AmbientLight(0x404060, 0.6);
scene.add(ambientLight);

sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
sunLight.position.set(50, 80, 30);
sunLight.castShadow = true;
sunLight.shadow.mapSize.width = 4096;
sunLight.shadow.mapSize.height = 4096;
sunLight.shadow.camera.left = -150;
sunLight.shadow.camera.right = 150;
sunLight.shadow.camera.top = 150;
sunLight.shadow.camera.bottom = -150;
sunLight.shadow.bias = -0.0001;
scene.add(sunLight);

skyLight = new THREE.HemisphereLight(0x87CEEB, 0xf0e68c, 0.6);
scene.add(skyLight);

scene.fog = new THREE.FogExp2(0x87CEEB, 0.015);
updateTimeOfDayLighting();

console.log('Lighting setup ‚úì');
}

function updateTimeOfDayLighting() {
const t = CONFIG.timeOfDay;
const sunMult = CONFIG.sunIntensity;

// Sun position: 0 = midnight, 6 = sunrise east, 12 = noon, 18 = sunset west
const sunAngle = (t / 24) * Math.PI * 2 - Math.PI / 2;
const radius = 180;
const sunY = Math.sin(sunAngle) * radius;
const sunX = Math.cos(sunAngle) * radius;
sunLight.position.set(sunX, Math.max(5, sunY), 80);
sunLight.target.position.set(0, 0, 0);

// Sun color & intensity: warm at dawn/dusk, white at noon, dim at night
const isDay = sunY > -20;
let sunColor, sunIntensity, ambientColor, ambientIntensity, skyColor, groundColor, fogColor;

if (!isDay) {
sunColor = new THREE.Color(0x223366);
sunIntensity = 0.15 * sunMult;
ambientColor = 0x0a1628;
ambientIntensity = 0.4;
skyColor = 0x0a1628;
groundColor = 0x050810;
fogColor = 0x0a1628;
} else {
const heightNorm = (sunY + 20) / 140;
sunIntensity = (0.4 + heightNorm * 1.1) * sunMult;
const warmth = Math.exp(-Math.pow((t - 12) / 4, 2));
sunColor = new THREE.Color().setHSL(0.08 + (1 - warmth) * 0.05, 0.3, 0.95);
ambientColor = new THREE.Color().setHSL(0.6 - warmth * 0.1, 0.4, 0.5).getHex();
ambientIntensity = 0.35 + heightNorm * 0.35;
skyColor = new THREE.Color().setHSL(0.55 + warmth * 0.08, 0.5, 0.65).getHex();
groundColor = new THREE.Color().setHSL(0.12, 0.4, 0.5).getHex();
fogColor = new THREE.Color().setHSL(0.55 + warmth * 0.06, 0.4, 0.6).getHex();
}

sunLight.color.copy(sunColor);
sunLight.intensity = sunIntensity;
ambientLight.color.setHex(ambientColor);
ambientLight.intensity = ambientIntensity;
skyLight.color.setHex(skyColor);
skyLight.groundColor.setHex(groundColor);
skyLight.intensity = 0.5 + (isDay ? 0.3 : 0);
scene.background = new THREE.Color(fogColor);
scene.fog.color.setHex(fogColor);
scene.fog.density = isDay ? 0.012 : 0.025;
}

// ==========================================
// PARTICLE WATER SYSTEM (100x MORE PARTICLES, BETTER WAVES)
// ==========================================

class ParticleWaterSystem {
constructor() {
console.log('Creating particle water system (250k points)...');
this.time = 0;
this.gridSize = 500;
this.spacing = 0.3;
const total = this.gridSize * this.gridSize;

const positions = new Float32Array(total * 3);
const colors = new Float32Array(total * 3);
let i = 0;
for (let gz = 0; gz < this.gridSize; gz++) {
for (let gx = 0; gx < this.gridSize; gx++) {
const x = (gx - this.gridSize / 2) * this.spacing;
const z = (gz - this.gridSize / 2) * this.spacing;
positions[i++] = x;
positions[i++] = 0;
positions[i++] = z;
const depth = 0.4 + 0.5 * (1 + Math.sin(x * 0.02) * Math.cos(z * 0.02));
colors[i - 3] = 0.0;
colors[i - 2] = 0.35 * depth;
colors[i - 1] = 0.6 * depth;
}
}

const geometry = new THREE.BufferGeometry();
geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

const material = new THREE.PointsMaterial({
size: 0.2,
transparent: true,
opacity: 0.85,
vertexColors: true,
sizeAttenuation: true,
depthWrite: true
});

this.points = new THREE.Points(geometry, material);
this.points.frustumCulled = false;
scene.add(this.points);
this.positionArray = positions;
console.log(`Created ${total} water particles ‚úì`);
}

waveHeight(x, z, t) {
const k = CONFIG.waveIntensity;
const s = CONFIG.waveSpeed * t;
return (
Math.sin(x * 0.04 + s) * k +
Math.sin(z * 0.035 + s * 0.87) * k * 0.85 +
Math.sin((x + z) * 0.025 + s * 1.1) * k * 0.6 +
Math.sin(x * 0.08 - z * 0.03 + s * 0.7) * k * 0.4 +
Math.sin((x - z) * 0.02 + s * 1.3) * k * 0.35 +
Math.sin(x * 0.015 + z * 0.02 + s * 0.5) * k * 0.25
);
}

update(deltaTime) {
this.time += deltaTime;
const t = this.time;
const pos = this.positionArray;
const gs = this.gridSize;
const sp = this.spacing;

for (let gz = 0; gz < gs; gz++) {
for (let gx = 0; gx < gs; gx++) {
const idx = (gz * gs + gx) * 3;
const x = pos[idx];
const z = pos[idx + 2];
pos[idx + 1] = this.waveHeight(x, z, t);
}
}

this.points.geometry.attributes.position.needsUpdate = true;
}

getHeightAt(x, z) {
return this.waveHeight(x, z, this.time);
}

disturb(x, z, strength) {
// Visual only - wave formula handles motion
}

remove() {
scene.remove(this.points);
this.points.geometry.dispose();
this.points.material.dispose();
}
}

// ==========================================
// MESH WATER SYSTEM (HIGH PERFORMANCE MODE)
// ==========================================

class MeshWaterSystem {
constructor() {
console.log('Creating hyperrealistic mesh water system...');
this.time = 0;

const w = 150, h = 150;
const geometry = new THREE.PlaneGeometry(w, h, 128, 128);
geometry.rotateX(-Math.PI / 2);

const material = new THREE.MeshPhongMaterial({
color: 0x0066aa,
emissive: 0x001a33,
specular: 0xbbeeff,
shininess: 140,
transparent: true,
opacity: 0.94,
side: THREE.DoubleSide,
depthWrite: true,
flatShading: false
});

this.mesh = new THREE.Mesh(geometry, material);
this.mesh.position.set(0, 0, 0);
this.mesh.receiveShadow = true;
this.mesh.castShadow = true;
this.mesh.renderOrder = 0;
scene.add(this.mesh);

this.originalPositions = geometry.attributes.position.array.slice();
console.log('Hyperrealistic mesh water created ‚úì');
}

waveHeight(x, z, t) {
const k = CONFIG.waveIntensity;
const s = CONFIG.waveSpeed * t;
return (
Math.sin(x * 0.04 + s) * k +
Math.sin(z * 0.035 + s * 0.87) * k * 0.85 +
Math.sin((x + z) * 0.025 + s * 1.1) * k * 0.6 +
Math.sin(x * 0.08 - z * 0.03 + s * 0.7) * k * 0.4 +
Math.sin((x - z) * 0.02 + s * 1.3) * k * 0.35 +
Math.sin(x * 0.015 + z * 0.02 + s * 0.5) * k * 0.25
);
}

update(deltaTime) {
this.time += deltaTime;
const positions = this.mesh.geometry.attributes.position.array;
const t = this.time;

for (let i = 0; i < positions.length / 3; i++) {
const idx = i * 3;
const x = this.originalPositions[idx];
const z = this.originalPositions[idx + 2];
positions[idx + 1] = this.waveHeight(x, z, t);
}

this.mesh.geometry.attributes.position.needsUpdate = true;
this.mesh.geometry.computeVertexNormals();
}

getHeightAt(x, z) {
return this.waveHeight(x, z, this.time);
}

disturb(x, z, strength) {
// Visual feedback only for mesh mode
}

remove() {
scene.remove(this.mesh);
}
}

// ==========================================
// BEACH
// ==========================================

function createBeach() {
console.log('Creating beach...');

const sandGeo = new THREE.PlaneGeometry(200, 100);
sandGeo.rotateX(-Math.PI / 2);
const sandMat = new THREE.MeshStandardMaterial({ color: 0xe8d4b8, roughness: 0.92 });
const sand = new THREE.Mesh(sandGeo, sandMat);
sand.position.set(0, -0.5, -60);
sand.receiveShadow = true;
scene.add(sand);

const seabedGeo = new THREE.PlaneGeometry(200, 200);
seabedGeo.rotateX(-Math.PI / 2);
const seabedMat = new THREE.MeshStandardMaterial({ color: 0x8b7355 });
const seabed = new THREE.Mesh(seabedGeo, seabedMat);
seabed.position.y = -8;
seabed.receiveShadow = true;
scene.add(seabed);

// Palm trees
const palmPositions = [[-45, -0.3, -55], [50, -0.3, -48], [-55, -0.3, -35], [35, -0.3, -58]];
palmPositions.forEach(([x, y, z]) => {
const palm = new THREE.Group();
const trunkGeo = new THREE.CylinderGeometry(0.4, 0.7, 8, 8);
const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8b6914, roughness: 0.9 });
const trunk = new THREE.Mesh(trunkGeo, trunkMat);
trunk.castShadow = true;
trunk.receiveShadow = true;
palm.add(trunk);
const leavesGeo = new THREE.ConeGeometry(3, 4, 8);
const leavesMat = new THREE.MeshStandardMaterial({ color: 0x228b22, roughness: 0.8 });
const leaves = new THREE.Mesh(leavesGeo, leavesMat);
leaves.position.y = 4.5;
leaves.castShadow = true;
palm.add(leaves);
palm.position.set(x, y, z);
palm.rotation.y = Math.random() * Math.PI * 2;
scene.add(palm);
beachObjects.push(palm);
});

// Rocks
const rockPositions = [[-30, -0.2, -50], [25, -0.3, -52], [0, -0.4, -58], [-15, -0.2, -45]];
rockPositions.forEach(([x, y, z], i) => {
const rockGeo = new THREE.DodecahedronGeometry(0.8 + Math.random() * 0.8, 0);
const rockMat = new THREE.MeshStandardMaterial({ color: 0x6b6b6b, roughness: 0.95 });
const rock = new THREE.Mesh(rockGeo, rockMat);
rock.position.set(x, y, z);
rock.rotation.set(Math.random() * 0.3, Math.random() * Math.PI * 2, Math.random() * 0.2);
rock.scale.setScalar(0.8 + Math.random() * 0.6);
rock.castShadow = true;
rock.receiveShadow = true;
scene.add(rock);
beachObjects.push(rock);
});

console.log('Beach created ‚úì');
}

// ==========================================
// PEOPLE
// ==========================================

class Person {
constructor(position) {
this.position = position.clone();
this.velocity = new THREE.Vector3();
this.direction = new THREE.Vector2(Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();
this.speed = 0.5 + Math.random() * 0.5;
this.time = Math.random() * 10;
this.changeTimer = 0;

this.createMesh();
}

createMesh() {
const group = new THREE.Group();
const skinColors = [0xffe4c9, 0xffd4b8, 0xe8c4a8, 0xd4a574, 0xc4956a, 0xa67c52];
const skinColor = skinColors[Math.floor(Math.random() * skinColors.length)];
const bodyMat = new THREE.MeshStandardMaterial({
color: skinColor,
roughness: 0.75,
metalness: 0.05
});

// Torso
const bodyGeo = new THREE.CylinderGeometry(0.28, 0.32, 0.75, 12);
const body = new THREE.Mesh(bodyGeo, bodyMat);
body.position.y = 0.15;
body.castShadow = true;
body.receiveShadow = true;
group.add(body);

// Head (proportional)
const headGeo = new THREE.SphereGeometry(0.22, 14, 14);
const head = new THREE.Mesh(headGeo, bodyMat);
head.position.y = 0.58;
head.castShadow = true;
head.receiveShadow = true;
group.add(head);

// Hair
const hairMat = new THREE.MeshStandardMaterial({ color: [0x3d2314, 0x5c4033, 0x2c1810, 0x4a3728][Math.floor(Math.random() * 4)], roughness: 0.9 });
const hairGeo = new THREE.SphereGeometry(0.2, 8, 8, 0, Math.PI * 2, 0, Math.PI * 0.55);
const hair = new THREE.Mesh(hairGeo, hairMat);
hair.position.y = 0.65;
hair.scale.set(1, 1.1, 0.95);
hair.castShadow = true;
group.add(hair);

// Swimwear
const swimColor = [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf9ca24, 0xff8c42, 0x9b59b6][Math.floor(Math.random() * 6)];
const swimMat = new THREE.MeshStandardMaterial({ color: swimColor, roughness: 0.5, metalness: 0 });
const swimGeo = new THREE.CylinderGeometry(0.26, 0.28, 0.35, 10);
const swim = new THREE.Mesh(swimGeo, swimMat);
swim.position.y = -0.18;
swim.rotation.x = Math.PI / 2;
swim.castShadow = true;
group.add(swim);

// Arms (simple cylinders)
const armGeo = new THREE.CylinderGeometry(0.04, 0.035, 0.35, 6);
const armL = new THREE.Mesh(armGeo, bodyMat);
armL.position.set(-0.28, 0.1, 0);
armL.rotation.z = 0.4;
armL.castShadow = true;
group.add(armL);
const armR = new THREE.Mesh(armGeo, bodyMat);
armR.position.set(0.28, 0.1, 0);
armR.rotation.z = -0.4;
armR.castShadow = true;
group.add(armR);

// Legs
const legGeo = new THREE.CylinderGeometry(0.06, 0.05, 0.4, 8);
const legMat = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.8 });
const legL = new THREE.Mesh(legGeo, legMat);
legL.position.set(-0.1, -0.42, 0.05);
legL.rotation.x = 0.15;
legL.castShadow = true;
group.add(legL);
const legR = new THREE.Mesh(legGeo, legMat);
legR.position.set(0.1, -0.42, 0.05);
legR.rotation.x = 0.15;
legR.castShadow = true;
group.add(legR);

group.position.copy(this.position);
group.scale.setScalar(1.15);
group.visible = true;
scene.add(group);
this.mesh = group;
}

update(deltaTime) {
this.time += deltaTime * 2;
this.changeTimer += deltaTime;

if (CONFIG.animatePeople) {
if (this.changeTimer > 3) {
this.changeTimer = 0;
this.direction = new THREE.Vector2(Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();
}
this.velocity.x = this.direction.x * this.speed;
this.velocity.z = this.direction.y * this.speed;
this.position.x += this.velocity.x * deltaTime;
this.position.z += this.velocity.z * deltaTime;
if (Math.abs(this.position.x) > 60) {
this.position.x = Math.sign(this.position.x) * 60;
this.direction.x *= -1;
}
if (this.position.z > 60 || this.position.z < -40) {
this.position.z = Math.max(-40, Math.min(60, this.position.z));
this.direction.y *= -1;
}
if (this.velocity.length() > 0.1) {
const angle = Math.atan2(this.velocity.x, this.velocity.z);
this.mesh.rotation.y = angle;
}
}

// Always update height and position so people stay visible on water
const waveHeight = (ocean && ocean.getHeightAt) ? ocean.getHeightAt(this.position.x, this.position.z) : 0;
this.position.y = waveHeight - 0.2 + Math.sin(this.time) * 0.15;
this.mesh.position.copy(this.position);
}

remove() {
scene.remove(this.mesh);
}
}

function updatePeople() {
while (people.length < CONFIG.peopleCount) {
const x = (Math.random() - 0.5) * 100;
const z = (Math.random() - 0.5) * 80;
people.push(new Person(new THREE.Vector3(x, 0, z)));
}

while (people.length > CONFIG.peopleCount) {
const person = people.pop();
person.remove();
}

document.getElementById('peopleCount').textContent = people.length;
}

// ==========================================
// PARTICLE SYSTEM (SPLASHES)
// ==========================================

class SplashParticleSystem {
constructor() {
this.particles = [];

const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(1000 * 3);
const colors = new Float32Array(1000 * 3);

geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

const material = new THREE.PointsMaterial({
size: 0.12,
transparent: true,
opacity: 0.8,
vertexColors: true,
blending: THREE.AdditiveBlending,
depthWrite: false
});

this.points = new THREE.Points(geometry, material);
scene.add(this.points);
}

emit(position, count = 10) {
if (!CONFIG.showSplashes) return;

for (let i = 0; i < count && this.particles.length < 1000; i++) {
this.particles.push({
position: position.clone().add(new THREE.Vector3(
(Math.random() - 0.5) * 2,
Math.random(),
(Math.random() - 0.5) * 2
)),
velocity: new THREE.Vector3(
(Math.random() - 0.5) * 3,
Math.random() * 2 + 1,
(Math.random() - 0.5) * 3
),
life: 2000
});
}
}

update(deltaTime) {
const positions = this.points.geometry.attributes.position.array;
const colors = this.points.geometry.attributes.color.array;
let activeCount = 0;

for (let i = this.particles.length - 1; i >= 0; i--) {
const p = this.particles[i];

p.velocity.y += -9.8 * deltaTime * 0.5;
p.position.add(p.velocity.clone().multiplyScalar(deltaTime));
p.life -= deltaTime * 1000;

if (p.life <= 0 || p.position.y < -2) {
this.particles.splice(i, 1);
continue;
}

const idx = activeCount * 3;
positions[idx] = p.position.x;
positions[idx + 1] = p.position.y;
positions[idx + 2] = p.position.z;

colors[idx] = 0.5;
colors[idx + 1] = 0.8;
colors[idx + 2] = 1;

activeCount++;
}

this.points.geometry.setDrawRange(0, activeCount);
this.points.geometry.attributes.position.needsUpdate = true;
this.points.geometry.attributes.color.needsUpdate = true;

document.getElementById('particleCount').textContent = activeCount;
}
}

// ==========================================
// BIRDS
// ==========================================

class BirdsSystem {
constructor() {
this.birds = [];
const count = 5;
for (let i = 0; i < count; i++) {
const group = new THREE.Group();
const bodyGeo = new THREE.SphereGeometry(0.15, 6, 6);
const bodyMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
const body = new THREE.Mesh(bodyGeo, bodyMat);
group.add(body);
const wingGeo = new THREE.SphereGeometry(0.08, 4, 4);
const wing = new THREE.Mesh(wingGeo, bodyMat);
wing.scale.set(2, 0.5, 1);
wing.position.x = 0.1;
group.add(wing);
group.position.set(
(Math.random() - 0.5) * 120,
25 + Math.random() * 40,
(Math.random() - 0.5) * 80
);
group.userData = {
phase: Math.random() * Math.PI * 2,
speed: 0.3 + Math.random() * 0.4,
radius: 40 + Math.random() * 30,
centerX: (Math.random() - 0.5) * 60,
centerZ: (Math.random() - 0.5) * 40,
wingPhase: Math.random() * Math.PI * 2
};
scene.add(group);
this.birds.push(group);
}
}

update(deltaTime) {
this.birds.forEach(b => {
const u = b.userData;
u.phase += u.speed * deltaTime;
b.position.x = u.centerX + Math.cos(u.phase) * u.radius;
b.position.z = u.centerZ + Math.sin(u.phase) * u.radius;
b.position.y = 25 + Math.sin(u.phase * 0.7) * 15;
b.rotation.y = -u.phase;
u.wingPhase += 15 * deltaTime;
b.children[1].scale.x = 2 + Math.sin(u.wingPhase) * 0.5;
});
}
}

// ==========================================
// MODE SWITCHING
// ==========================================

function switchRenderMode() {
const mode = document.getElementById('renderMode').value;
console.log('Switching to mode:', mode);

if (ocean) ocean.remove();

if (mode === 'particle') {
ocean = new ParticleWaterSystem();
document.getElementById('currentMode').textContent = 'PARTICLE';
document.getElementById('waterType').textContent = '250k Points';
} else {
ocean = new MeshWaterSystem();
document.getElementById('currentMode').textContent = 'ULTRA';
document.getElementById('waterType').textContent = 'Mesh';
}

CONFIG.renderMode = mode;
showNotification(`Switched to ${mode.toUpperCase()} mode!`);
}

// ==========================================
// UI FUNCTIONS
// ==========================================

function updateWaveIntensity(val) {
CONFIG.waveIntensity = parseFloat(val);
document.getElementById('waveIntensityVal').textContent = val;
}

function updateWaveSpeed(val) {
CONFIG.waveSpeed = parseFloat(val);
document.getElementById('waveSpeedVal').textContent = val + 'x';
}

function updatePeopleCount(val) {
CONFIG.peopleCount = parseInt(val);
document.getElementById('peopleCountVal').textContent = val;
updatePeople();
}

function updateTimeOfDay(val) {
CONFIG.timeOfDay = parseFloat(val);
const labels = ['Midnight', 'Dawn', 'Morning', 'Noon', 'Afternoon', 'Sunset', 'Night'];
const idx = Math.min(6, Math.floor(val / 4));
document.getElementById('timeVal').textContent = labels[idx] || 'Night';
updateTimeOfDayLighting();
}

function updateSunIntensity(val) {
CONFIG.sunIntensity = parseFloat(val);
document.getElementById('sunVal').textContent = val;
updateTimeOfDayLighting();
}

function toggleAnimation(checked) {
CONFIG.animatePeople = checked;
}

function toggleSplashes(checked) {
CONFIG.showSplashes = checked;
}

function togglePanel() {
document.getElementById('control-panel').classList.toggle('collapsed');
}

// ==========================================
// ACTIONS
// ==========================================

function createBigWave() {
for (let i = 0; i < 50; i++) {
setTimeout(() => {
const angle = (i / 50) * Math.PI * 2;
const x = Math.cos(angle) * 30;
const z = Math.sin(angle) * 30;
ocean.disturb(x, z, -5);
if (particleSystem) particleSystem.emit(new THREE.Vector3(x, 0, z), 5);
}, i * 30);
}
showNotification('üåä Big wave generated!');
}

function addPerson() {
if (CONFIG.peopleCount >= 20) return;
CONFIG.peopleCount++;
document.getElementById('peopleSlider').value = CONFIG.peopleCount;
updatePeople();
showNotification('‚ûï Person added!');
}

function resetScene() {
CONFIG.waveIntensity = 1.2;
CONFIG.waveSpeed = 1.0;
CONFIG.peopleCount = 8;

document.getElementById('waveIntensity').value = 1.2;
document.getElementById('waveSpeed').value = 1.0;
document.getElementById('peopleSlider').value = 8;

updatePeople();
showNotification('‚Üª Scene reset!');
}

function randomizeScene() {
CONFIG.waveIntensity = 0.5 + Math.random() * 2;
CONFIG.waveSpeed = 0.5 + Math.random() * 2;

document.getElementById('waveIntensity').value = CONFIG.waveIntensity;
document.getElementById('waveSpeed').value = CONFIG.waveSpeed;

updateWaveIntensity(CONFIG.waveIntensity);
updateWaveSpeed(CONFIG.waveSpeed);

showNotification('üé≤ Scene randomized!');
}

function loadPreset(preset) {
const presets = {
morning: { time: 7, intensity: 0.8, speed: 0.7, sun: 1.2 },
noon: { time: 12, intensity: 1.2, speed: 1.0, sun: 1.5 },
sunset: { time: 18, intensity: 1.0, speed: 0.8, sun: 1.3 },
storm: { time: 15, intensity: 2.5, speed: 2.0, sun: 0.8 }
};

const p = presets[preset];
CONFIG.timeOfDay = p.time;
CONFIG.waveIntensity = p.intensity;
CONFIG.waveSpeed = p.speed;
CONFIG.sunIntensity = p.sun;

document.getElementById('timeOfDay').value = p.time;
document.getElementById('waveIntensity').value = p.intensity;
document.getElementById('waveSpeed').value = p.speed;
document.getElementById('sunIntensity').value = p.sun;

updateWaveIntensity(p.intensity);
updateWaveSpeed(p.speed);
updateSunIntensity(p.sun);
updateTimeOfDay(p.time);

showNotification(`üé¨ ${preset.toUpperCase()} preset loaded!`);
}

function addPersonAt() {
addPerson();
hideContextMenu();
}

function createWaveAt() {
createBigWave();
hideContextMenu();
}

function spawnBeachBall() {
showNotification('üèê Beach ball spawned!');
hideContextMenu();
}

// ==========================================
// CONTEXT MENU
// ==========================================

const contextMenu = document.getElementById('context-menu');

window.addEventListener('contextmenu', (e) => {
e.preventDefault();
contextMenu.style.display = 'block';
contextMenu.style.left = e.clientX + 'px';
contextMenu.style.top = e.clientY + 'px';
});

function hideContextMenu() {
contextMenu.style.display = 'none';
}

window.addEventListener('click', (e) => {
if (!e.target.closest('#context-menu')) hideContextMenu();
});

// ==========================================
// NOTIFICATIONS
// ==========================================

function showNotification(message) {
const notif = document.createElement('div');
notif.className = 'notification';
notif.textContent = message;
document.body.appendChild(notif);

setTimeout(() => {
notif.style.animation = 'notifSlide 0.3s ease reverse';
setTimeout(() => notif.remove(), 300);
}, 2500);
}

// ==========================================
// WINDOW RESIZE
// ==========================================

window.addEventListener('resize', () => {
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
});

// ==========================================
// ANIMATION LOOP
// ==========================================

let lastTime = performance.now();
let frames = 0;
let lastFpsUpdate = performance.now();

function animate() {
requestAnimationFrame(animate);

const currentTime = performance.now();
const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
lastTime = currentTime;

if (ocean) ocean.update(deltaTime);
people.forEach(person => person.update(deltaTime));
if (particleSystem) particleSystem.update(deltaTime);
if (birdsSystem) birdsSystem.update(deltaTime);

updateTimeOfDayLighting();

controls.update();
renderer.render(scene, camera);

frames++;
if (currentTime - lastFpsUpdate >= 1000) {
document.getElementById('fps').textContent = frames;
frames = 0;
lastFpsUpdate = currentTime;
}
}

// ==========================================
// INITIALIZATION
// ==========================================

const LOADING_TIPS = [
'Try the Sunset preset for golden hour.',
'Right-click anywhere to add people or create waves.',
'Use the Time of Day slider to see dawn and dusk.',
'Particle mode runs better on older devices.',
'Generate Big Wave for instant splashes!'
];

function init() {
console.log('üèñÔ∏è Starting OceanLife Pro...');

const progress = document.getElementById('progress');
const status = document.getElementById('load-status');
const tipEl = document.getElementById('loading-tip');
if (tipEl) tipEl.textContent = LOADING_TIPS[Math.floor(Math.random() * LOADING_TIPS.length)];

setTimeout(() => {
progress.style.width = '20%';
status.textContent = 'Initializing scene...';
initScene();
}, 100);

setTimeout(() => {
progress.style.width = '40%';
status.textContent = 'Setting up lighting...';
setupLighting();
}, 300);

setTimeout(() => {
progress.style.width = '60%';
status.textContent = 'Creating beach...';
createBeach();
}, 500);

setTimeout(() => {
progress.style.width = '75%';
status.textContent = 'Creating water system...';
ocean = new MeshWaterSystem();
particleSystem = new SplashParticleSystem();
}, 700);

setTimeout(() => {
progress.style.width = '88%';
status.textContent = 'Adding birds...';
birdsSystem = new BirdsSystem();
}, 800);

setTimeout(() => {
progress.style.width = '100%';
status.textContent = 'Spawning people...';
updatePeople();
}, 900);

setTimeout(() => {
document.getElementById('loading-screen').style.opacity = '0';
setTimeout(() => {
document.getElementById('loading-screen').style.display = 'none';
animate();
showNotification('üèñÔ∏è Welcome to OceanLife Pro!');
console.log('‚úì OceanLife Pro ready!');
}, 800);
}, 1200);
}

// Start when DOM is ready
if (document.readyState === 'loading') {
document.addEventListener('DOMContentLoaded', init);
} else {
init();
}

</script>
</body>
</html>