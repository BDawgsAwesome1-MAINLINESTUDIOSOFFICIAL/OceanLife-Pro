<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>OceanLife Pro - Interactive Beach Simulation</title>

<!-- SEO & Social -->
<meta name="description" content="Interactive beach simulation with dynamic waves, animated people, and physics sandbox. Drop objects, import 3D models, and explore. Built with Three.js.">
<meta name="keywords" content="beach simulation, ocean, waves, Three.js, WebGL, 3D, interactive, realistic">
<meta name="author" content="OceanLife Pro">
<meta name="theme-color" content="#0a4d6e">

<!-- Open Graph / Facebook -->
<meta property="og:type" content="website">
<meta property="og:title" content="OceanLife Pro - Interactive Beach Simulation">
<meta property="og:description" content="Interactive beach simulation with physics sandbox. Drop objects, import 3D models, and explore.">
<meta property="og:image" content="https://images.unsplash.com/photo-1507525428034-b723cf961d3e?w=1200">

<!-- Twitter -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="OceanLife Pro - Interactive Beach Simulation">
<meta name="twitter:description" content="Interactive beach simulation with physics sandbox.">

<!-- PWA -->
<link rel="manifest" href="data:application/json,{&quot;name&quot;:&quot;OceanLife Pro&quot;,&quot;short_name&quot;:&quot;OceanLife&quot;,&quot;start_url&quot;:&quot;.&quot;,&quot;display&quot;:&quot;fullscreen&quot;,&quot;background_color&quot;:&quot;%230a4d6e&quot;,&quot;theme_color&quot;:&quot;%230a4d6e&quot;}">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<!-- Favicon (inline SVG) -->
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üèñÔ∏è</text></svg>">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
margin: 0;
overflow: hidden;
background: linear-gradient(135deg, #87CEEB 0%, #E0F6FF 100%);
font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
color: white;
-webkit-font-smoothing: antialiased;
}

/* Loading Screen */
#loading-screen {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: linear-gradient(135deg, #0a4d6e 0%, #1a7fa0 100%);
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
z-index: 10000;
transition: opacity 0.8s ease;
}

.loader-container {
text-align: center;
}

.wave-loader {
width: 100px;
height: 100px;
margin: 0 auto 30px;
position: relative;
}

.wave {
position: absolute;
width: 100%;
height: 100%;
border-radius: 50%;
border: 3px solid rgba(255, 255, 255, 0.3);
animation: wave-pulse 2s ease-in-out infinite;
}

.wave:nth-child(2) { animation-delay: 0.5s; }
.wave:nth-child(3) { animation-delay: 1s; }

@keyframes wave-pulse {
0% {
transform: scale(0.3);
opacity: 1;
}
100% {
transform: scale(1.5);
opacity: 0;
}
}

.loading-text {
font-size: 24px;
color: white;
margin-bottom: 10px;
font-weight: 600;
}

.loading-subtext {
font-size: 14px;
color: rgba(255, 255, 255, 0.7);
margin-top: 10px;
}

.loading-tip {
font-size: 12px;
color: rgba(255, 255, 255, 0.5);
margin-top: 24px;
max-width: 280px;
text-align: center;
font-style: italic;
}

.progress-bar {
width: 300px;
height: 4px;
background: rgba(255, 255, 255, 0.2);
border-radius: 2px;
overflow: hidden;
margin: 20px auto;
}

.progress-fill {
height: 100%;
background: linear-gradient(90deg, #00d4ff, #0af);
width: 0%;
transition: width 0.3s ease;
box-shadow: 0 0 10px rgba(0, 200, 255, 0.5);
}

/* Main UI */
#control-panel {
position: absolute;
top: 20px;
left: 20px;
background: rgba(10, 25, 40, 0.92);
padding: 25px;
border-radius: 20px;
backdrop-filter: blur(20px);
border: 1px solid rgba(255, 255, 255, 0.18);
box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
max-width: 380px;
max-height: 90vh;
overflow-y: auto;
transition: all 0.3s ease;
}

#control-panel.collapsed {
transform: translateX(-340px);
}

.panel-toggle {
position: absolute;
right: -40px;
top: 20px;
width: 40px;
height: 50px;
background: rgba(10, 25, 40, 0.92);
border: 1px solid rgba(255, 255, 255, 0.18);
border-left: none;
border-radius: 0 10px 10px 0;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
backdrop-filter: blur(20px);
transition: all 0.3s ease;
}

.panel-toggle:hover {
background: rgba(0, 168, 255, 0.3);
}

.panel-toggle::before {
content: '‚óÄ';
color: white;
font-size: 16px;
}

#control-panel.collapsed .panel-toggle::before {
content: '‚ñ∂';
}

#control-panel::-webkit-scrollbar { width: 8px; }
#control-panel::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.05); border-radius: 4px; }
#control-panel::-webkit-scrollbar-thumb { background: linear-gradient(180deg, #00d4ff, #0066cc); border-radius: 4px; }

h1 {
margin: 0 0 8px 0;
font-size: 28px;
font-weight: 700;
background: linear-gradient(135deg, #00d4ff 0%, #0af 50%, #fff 100%);
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
}

.subtitle {
font-size: 12px;
color: rgba(255, 255, 255, 0.6);
margin-bottom: 20px;
}

.section {
margin-bottom: 25px;
padding-bottom: 20px;
border-bottom: 1px solid rgba(255, 255, 255, 0.08);
}

.section:last-child { border-bottom: none; margin-bottom: 0; }

.section-title {
font-size: 13px;
color: #00d4ff;
text-transform: uppercase;
letter-spacing: 1.5px;
margin-bottom: 15px;
font-weight: 700;
display: flex;
align-items: center;
gap: 8px;
}

.control-group { margin-bottom: 15px; }

label {
display: block;
font-size: 13px;
color: rgba(255, 255, 255, 0.8);
margin-bottom: 8px;
font-weight: 500;
}

.value-display {
float: right;
color: #00d4ff;
font-weight: 700;
font-size: 12px;
}

input[type="range"] {
width: 100%;
height: 6px;
background: linear-gradient(90deg, rgba(0, 200, 255, 0.2), rgba(0, 200, 255, 0.4));
border-radius: 3px;
outline: none;
-webkit-appearance: none;
}

input[type="range"]::-webkit-slider-thumb {
-webkit-appearance: none;
width: 18px;
height: 18px;
background: linear-gradient(135deg, #00d4ff, #0066cc);
border-radius: 50%;
cursor: pointer;
box-shadow: 0 0 0 3px rgba(0, 200, 255, 0.3);
}

input[type="range"]::-moz-range-thumb {
width: 18px;
height: 18px;
background: linear-gradient(135deg, #00d4ff, #0066cc);
border-radius: 50%;
cursor: pointer;
border: none;
box-shadow: 0 0 0 3px rgba(0, 200, 255, 0.3);
}

button {
width: 100%;
background: linear-gradient(135deg, #0088ff 0%, #0066cc 100%);
border: none;
padding: 14px 20px;
color: white;
font-weight: 600;
border-radius: 12px;
cursor: pointer;
margin-bottom: 10px;
transition: all 0.3s ease;
font-size: 13px;
text-transform: uppercase;
letter-spacing: 1px;
box-shadow: 0 4px 15px rgba(0, 136, 255, 0.3);
}

button:hover {
transform: translateY(-2px);
box-shadow: 0 6px 25px rgba(0, 136, 255, 0.5);
}

button.active {
background: linear-gradient(135deg, #ff4757 0%, #cc0033 100%);
box-shadow: 0 4px 15px rgba(255, 71, 87, 0.4);
}

button.secondary {
background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
border: 1px solid rgba(255, 255, 255, 0.1);
}

.button-group {
display: grid;
grid-template-columns: 1fr 1fr;
gap: 10px;
margin-bottom: 10px;
}

.button-group button {
margin-bottom: 0;
font-size: 11px;
padding: 12px;
}

select {
width: 100%;
background: rgba(255, 255, 255, 0.08);
border: 1px solid rgba(255, 255, 255, 0.15);
color: white;
padding: 12px;
border-radius: 10px;
font-size: 13px;
cursor: pointer;
outline: none;
}

select option { background: #0a1928; color: white; }

.checkbox-container {
display: flex;
align-items: center;
margin-bottom: 12px;
cursor: pointer;
padding: 10px;
border-radius: 8px;
transition: all 0.2s ease;
}

.checkbox-container:hover { background: rgba(255, 255, 255, 0.05); }

.checkbox-container input[type="checkbox"] {
width: 20px;
height: 20px;
margin-right: 12px;
cursor: pointer;
accent-color: #00d4ff;
}

.checkbox-container label {
margin: 0;
cursor: pointer;
font-size: 13px;
}

/* Stats Panel */
#stats {
position: absolute;
top: 20px;
right: 20px;
background: rgba(10, 25, 40, 0.92);
padding: 20px;
border-radius: 16px;
font-family: 'Monaco', monospace;
font-size: 12px;
line-height: 1.8;
border: 1px solid rgba(255, 255, 255, 0.18);
min-width: 240px;
backdrop-filter: blur(20px);
}

.stat-line {
display: flex;
justify-content: space-between;
margin: 4px 0;
}

.stat-label { color: rgba(255, 255, 255, 0.7); }
.stat-value { color: #00ff88; font-weight: 700; }
.stat-title { font-size: 14px; font-weight: 700; margin-bottom: 10px; color: #00d4ff; }

/* Credits */
#credits {
position: absolute;
bottom: 20px;
left: 50%;
transform: translateX(-50%);
background: rgba(10, 25, 40, 0.85);
padding: 15px 30px;
border-radius: 12px;
border: 1px solid rgba(255, 255, 255, 0.15);
backdrop-filter: blur(20px);
text-align: center;
font-size: 12px;
color: rgba(255, 255, 255, 0.8);
}

#credits strong { color: #00d4ff; }

/* Notification */
.notification {
position: fixed;
top: 30px;
left: 50%;
transform: translateX(-50%);
background: linear-gradient(135deg, rgba(0, 200, 255, 0.95), rgba(0, 136, 255, 0.95));
color: white;
padding: 18px 30px;
border-radius: 12px;
box-shadow: 0 8px 30px rgba(0, 200, 255, 0.5);
z-index: 10001;
animation: notifSlide 0.4s ease;
font-weight: 600;
font-size: 14px;
}

@keyframes notifSlide {
from { transform: translateX(-50%) translateY(-100px); opacity: 0; }
to { transform: translateX(-50%) translateY(0); opacity: 1; }
}

.mode-badge {
display: inline-block;
background: linear-gradient(135deg, #ffd700, #ffed4e);
color: #000;
padding: 4px 12px;
border-radius: 20px;
font-size: 10px;
font-weight: 800;
margin-left: 10px;
}

/* Context Menu */
#context-menu {
position: absolute;
display: none;
background: rgba(15, 30, 45, 0.98);
border: 1px solid rgba(0, 200, 255, 0.4);
border-radius: 12px;
box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
padding: 8px 0;
z-index: 2000;
min-width: 220px;
backdrop-filter: blur(20px);
}

.menu-item {
padding: 14px 20px;
color: white;
cursor: pointer;
font-size: 13px;
transition: all 0.2s;
display: flex;
align-items: center;
}

.menu-item:hover {
background: linear-gradient(90deg, rgba(0, 200, 255, 0.3), transparent);
color: #00d4ff;
}

.menu-icon {
margin-right: 12px;
font-size: 18px;
width: 24px;
text-align: center;
}

.menu-divider {
height: 1px;
background: rgba(255, 255, 255, 0.1);
margin: 8px 12px;
}
</style>
</head>
<body>

<!-- Loading Screen -->
<div id="loading-screen">
<div class="loader-container">
<div class="wave-loader">
<div class="wave"></div>
<div class="wave"></div>
<div class="wave"></div>
</div>
<div class="loading-text">üèñÔ∏è OceanLife Pro</div>
<div class="loading-subtext">Interactive Beach Simulation</div>
<div class="progress-bar">
<div class="progress-fill" id="progress"></div>
</div>
<div class="loading-subtext" id="load-status">Starting...</div>
<div class="loading-tip" id="loading-tip"></div>
</div>
</div>

<!-- Performance Stats -->
<div id="stats">
<div class="stat-title">‚ö° Performance</div>
<div class="stat-line"><span class="stat-label">FPS:</span> <span class="stat-value" id="fps">60</span></div>
<div class="stat-line"><span class="stat-label">Mode:</span> <span class="stat-value" id="currentMode">ULTRA</span></div>
<div class="stat-line"><span class="stat-label">People:</span> <span class="stat-value" id="peopleCount">8</span></div>
<div class="stat-line"><span class="stat-label">Particles:</span> <span class="stat-value" id="particleCount">0</span></div>
<div class="stat-line"><span class="stat-label">Water:</span> <span class="stat-value" id="waterType">Mesh</span></div>
</div>

<!-- Main Control Panel -->
<div id="control-panel">
<div class="panel-toggle" onclick="togglePanel()"></div>

<h1>üèñÔ∏è OceanLife Pro</h1>
<div class="subtitle">Interactive Beach Simulation v1.0</div>

<div class="section">
<div class="section-title">üé¨ Rendering Mode</div>
<select id="renderMode" onchange="switchRenderMode()">
<option value="ultra">üåü Ultra Quality (Mesh Water)</option>
<option value="particle">üíß Particle Physics (Low-End)</option>
<option value="hybrid">‚ö° Hybrid Mode</option>
</select>
<div style="font-size: 11px; color: rgba(255,255,255,0.5); margin-top: 8px;">
Use Particle mode for older devices
</div>
</div>

<div class="section">
<div class="section-title">üåä Water Physics</div>

<div class="control-group">
<label>Wave Intensity <span class="value-display" id="waveIntensityVal">1.2</span></label>
<input type="range" id="waveIntensity" min="0.1" max="3.0" value="1.2" step="0.1" oninput="updateWaveIntensity(this.value)">
</div>

<div class="control-group">
<label>Wave Speed <span class="value-display" id="waveSpeedVal">1.0x</span></label>
<input type="range" id="waveSpeed" min="0.3" max="3.0" value="1.0" step="0.1" oninput="updateWaveSpeed(this.value)">
</div>
</div>

<div class="section">
<div class="section-title">üë• People Settings</div>

<div class="control-group">
<label>Number of People <span class="value-display" id="peopleCountVal">8</span></label>
<input type="range" id="peopleSlider" min="0" max="20" value="8" step="1" oninput="updatePeopleCount(this.value)">
</div>

<div class="checkbox-container">
<input type="checkbox" id="animatePeople" checked onchange="toggleAnimation(this.checked)">
<label for="animatePeople">Animate People</label>
</div>

<div class="checkbox-container">
<input type="checkbox" id="showSplashes" checked onchange="toggleSplashes(this.checked)">
<label for="showSplashes">Water Splashes</label>
</div>
</div>

<div class="section">
<div class="section-title">‚òÄÔ∏è Environment</div>

<div class="control-group">
<label>Time of Day <span class="value-display" id="timeVal">Noon</span></label>
<input type="range" id="timeOfDay" min="0" max="24" value="12" step="0.5" oninput="updateTimeOfDay(this.value)">
</div>

<div class="control-group">
<label>Sun Intensity <span class="value-display" id="sunVal">1.5</span></label>
<input type="range" id="sunIntensity" min="0.5" max="3" value="1.5" step="0.1" oninput="updateSunIntensity(this.value)">
</div>
</div>

<div class="section">
<div class="section-title">üéÆ Quick Actions</div>

<button onclick="createBigWave()">üåä Generate Big Wave</button>
<button onclick="addPerson()">‚ûï Add Person</button>

<div class="button-group">
<button class="secondary" onclick="resetScene()">‚Üª Reset</button>
<button class="secondary" onclick="randomizeScene()">üé≤ Random</button>
</div>
</div>

<div class="section">
<div class="section-title">üé¨ Presets</div>

<button class="secondary" onclick="loadPreset('morning')">üåÖ Morning</button>
<button class="secondary" onclick="loadPreset('noon')">‚òÄÔ∏è Noon</button>
<button class="secondary" onclick="loadPreset('sunset')">üåá Sunset</button>
<button class="secondary" onclick="loadPreset('storm')">‚õàÔ∏è Storm</button>
</div>

<div class="section">
<div class="section-title">üì¶ Physics Sandbox</div>

<button onclick="dropBox()">üì¶ Drop Box</button>
<button onclick="dropSphere()">‚öΩ Drop Sphere</button>

<div class="control-group">
<label>Object Weight <span class="value-display" id="weightVal">1.0</span></label>
<input type="range" id="objectWeight" min="0.1" max="5" value="1" step="0.1" oninput="updateObjectWeight(this.value)">
</div>

<div class="control-group">
<label>Object Scale <span class="value-display" id="scaleVal">1.0</span></label>
<input type="range" id="objectScale" min="0.2" max="3" value="1" step="0.1" oninput="updateObjectScale(this.value)">
</div>

<button class="secondary" onclick="clearPhysicsObjects()">üóëÔ∏è Clear Objects</button>
</div>

<div class="section">
<div class="section-title">üìÅ Import 3D Model</div>

<input type="file" id="modelInput" accept=".glb,.gltf,.obj" style="display:none" onchange="handleModelImport(event)">
<button onclick="document.getElementById('modelInput').click()">üìÇ Import GLB/OBJ</button>

<div id="importedModelControls" style="display:none; margin-top:10px;">
<div class="control-group">
<label>Model Scale <span class="value-display" id="modelScaleVal">1.0</span></label>
<input type="range" id="modelScale" min="0.1" max="5" value="1" step="0.1" oninput="updateModelScale(this.value)">
</div>
<div class="control-group">
<label>Model Weight <span class="value-display" id="modelWeightVal">1.0</span></label>
<input type="range" id="modelWeight" min="0.1" max="10" value="1" step="0.1" oninput="updateModelWeight(this.value)">
</div>
<button class="secondary" onclick="dropImportedModel()">üì• Drop Model</button>
</div>
</div>
</div>

<!-- Credits -->
<div id="credits">
<strong>OceanLife Pro v1.0</strong> ‚Äî WASD to move ¬∑ Drag to orbit ¬∑ Scroll to zoom ¬∑ Physics sandbox
</div>

<!-- Context Menu -->
<div id="context-menu">
<div class="menu-item" onclick="addPersonAt()">
<span class="menu-icon">üë§</span> Add Person Here
</div>
<div class="menu-item" onclick="createWaveAt()">
<span class="menu-icon">üåä</span> Create Wave
</div>
<div class="menu-divider"></div>
<div class="menu-item" onclick="spawnBeachBall()">
<span class="menu-icon">üèê</span> Beach Ball
</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>

<script>
console.log('üèñÔ∏è OceanLife Pro - Initializing...');

// ==========================================
// GLOBAL STATE
// ==========================================

const CONFIG = {
renderMode: 'ultra',
waveIntensity: 1.2,
waveSpeed: 1.0,
peopleCount: 8,
timeOfDay: 12,
sunIntensity: 1.5,
animatePeople: true,
showSplashes: true,
objectWeight: 1.0,
objectScale: 1.0,
modelScale: 1.0,
modelWeight: 1.0
};

let scene, camera, renderer, controls;
let ocean, people = [], beachObjects = [];
let particleSystem;
let waterParticles = [];
let sunLight, skyLight, ambientLight;
let birdsSystem;
let skyMesh;

// Physics objects
let physicsObjects = [];
let importedModel = null;
let gltfLoader, objLoader;

// WASD Movement controls (global scope)
const moveState = { forward: false, backward: false, left: false, right: false, up: false, down: false };
const moveSpeed = 1.5;

function setupWASDControls() {
window.addEventListener('keydown', (e) => {
  switch(e.code) {
    case 'KeyW': case 'ArrowUp': moveState.forward = true; break;
    case 'KeyS': case 'ArrowDown': moveState.backward = true; break;
    case 'KeyA': case 'ArrowLeft': moveState.left = true; break;
    case 'KeyD': case 'ArrowRight': moveState.right = true; break;
    case 'KeyQ': case 'Space': moveState.up = true; break;
    case 'KeyE': case 'ShiftLeft': moveState.down = true; break;
  }
});

window.addEventListener('keyup', (e) => {
  switch(e.code) {
    case 'KeyW': case 'ArrowUp': moveState.forward = false; break;
    case 'KeyS': case 'ArrowDown': moveState.backward = false; break;
    case 'KeyA': case 'ArrowLeft': moveState.left = false; break;
    case 'KeyD': case 'ArrowRight': moveState.right = false; break;
    case 'KeyQ': case 'Space': moveState.up = false; break;
    case 'KeyE': case 'ShiftLeft': moveState.down = false; break;
  }
});
}

function updateCameraMovement() {
if (!camera || !controls) return;

const direction = new THREE.Vector3();
camera.getWorldDirection(direction);
direction.y = 0;
direction.normalize();

const right = new THREE.Vector3();
right.crossVectors(direction, new THREE.Vector3(0, 1, 0));

if (moveState.forward) {
  camera.position.addScaledVector(direction, moveSpeed);
  controls.target.addScaledVector(direction, moveSpeed);
}
if (moveState.backward) {
  camera.position.addScaledVector(direction, -moveSpeed);
  controls.target.addScaledVector(direction, -moveSpeed);
}
if (moveState.left) {
  camera.position.addScaledVector(right, -moveSpeed);
  controls.target.addScaledVector(right, -moveSpeed);
}
if (moveState.right) {
  camera.position.addScaledVector(right, moveSpeed);
  controls.target.addScaledVector(right, moveSpeed);
}
if (moveState.up) {
  camera.position.y += moveSpeed;
  controls.target.y += moveSpeed;
}
if (moveState.down) {
  camera.position.y = Math.max(2, camera.position.y - moveSpeed);
  controls.target.y = Math.max(0, controls.target.y - moveSpeed);
}
}

// ==========================================
// SCENE SETUP
// ==========================================

function initScene() {
console.log('Initializing scene...');

scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);

camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 2500);
camera.position.set(0, 35, 90);
camera.lookAt(0, 0, -10);

renderer = new THREE.WebGLRenderer({ 
  antialias: true, 
  alpha: false,
  powerPreference: 'high-performance'
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.25;
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.physicallyCorrectLights = true;
document.body.appendChild(renderer.domElement);

controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.maxPolarAngle = Math.PI / 2.05;
controls.minDistance = 5;
controls.maxDistance = 350;
controls.target.set(0, 0, -10);

// Setup WASD controls
setupWASDControls();

console.log('Scene initialized ‚úì');
}

// ==========================================
// LIGHTING
// ==========================================

function setupLighting() {
console.log('Setting up lighting...');

ambientLight = new THREE.AmbientLight(0x404060, 0.6);
scene.add(ambientLight);

sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
sunLight.position.set(50, 80, 30);
sunLight.castShadow = true;
sunLight.shadow.mapSize.width = 4096;
sunLight.shadow.mapSize.height = 4096;
sunLight.shadow.camera.left = -150;
sunLight.shadow.camera.right = 150;
sunLight.shadow.camera.top = 150;
sunLight.shadow.camera.bottom = -150;
sunLight.shadow.bias = -0.0001;
scene.add(sunLight);

skyLight = new THREE.HemisphereLight(0x87CEEB, 0xf0e68c, 0.6);
scene.add(skyLight);

scene.fog = new THREE.FogExp2(0x87CEEB, 0.015);
updateTimeOfDayLighting();

console.log('Lighting setup ‚úì');
}

function updateTimeOfDayLighting() {
const t = CONFIG.timeOfDay;
const sunMult = CONFIG.sunIntensity;

// Sun position: 0 = midnight, 6 = sunrise east, 12 = noon, 18 = sunset west
const sunAngle = (t / 24) * Math.PI * 2 - Math.PI / 2;
const radius = 180;
const sunY = Math.sin(sunAngle) * radius;
const sunX = Math.cos(sunAngle) * radius;
sunLight.position.set(sunX, Math.max(5, sunY), 80);
sunLight.target.position.set(0, 0, 0);

// Sun color & intensity: warm at dawn/dusk, white at noon, dim at night
const isDay = sunY > -20;
let sunColor, sunIntensity, ambientColor, ambientIntensity, skyColor, groundColor, fogColor;

if (!isDay) {
sunColor = new THREE.Color(0x223366);
sunIntensity = 0.15 * sunMult;
ambientColor = 0x0a1628;
ambientIntensity = 0.4;
skyColor = 0x0a1628;
groundColor = 0x050810;
fogColor = 0x0a1628;
} else {
const heightNorm = (sunY + 20) / 140;
sunIntensity = (0.4 + heightNorm * 1.1) * sunMult;
const warmth = Math.exp(-Math.pow((t - 12) / 4, 2));
sunColor = new THREE.Color().setHSL(0.08 + (1 - warmth) * 0.05, 0.3, 0.95);
ambientColor = new THREE.Color().setHSL(0.6 - warmth * 0.1, 0.4, 0.5).getHex();
ambientIntensity = 0.35 + heightNorm * 0.35;
skyColor = new THREE.Color().setHSL(0.55 + warmth * 0.08, 0.5, 0.65).getHex();
groundColor = new THREE.Color().setHSL(0.12, 0.4, 0.5).getHex();
fogColor = new THREE.Color().setHSL(0.55 + warmth * 0.06, 0.4, 0.6).getHex();
}

sunLight.color.copy(sunColor);
sunLight.intensity = sunIntensity;
ambientLight.color.setHex(ambientColor);
ambientLight.intensity = ambientIntensity;
skyLight.color.setHex(skyColor);
skyLight.groundColor.setHex(groundColor);
skyLight.intensity = 0.5 + (isDay ? 0.3 : 0);
scene.background = new THREE.Color(fogColor);
scene.fog.color.setHex(fogColor);
scene.fog.density = isDay ? 0.012 : 0.025;
}

// ==========================================
// CIRCLE PARTICLE WATER SYSTEM (500+ visible circles)
// ==========================================

// Create circular disc texture for particles
function createCircleTexture() {
const canvas = document.createElement('canvas');
canvas.width = 64;
canvas.height = 64;
const ctx = canvas.getContext('2d');

// Gradient circle for soft edges
const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
gradient.addColorStop(0, 'rgba(0, 180, 255, 1)');
gradient.addColorStop(0.3, 'rgba(0, 140, 220, 0.9)');
gradient.addColorStop(0.6, 'rgba(0, 100, 180, 0.6)');
gradient.addColorStop(1, 'rgba(0, 60, 120, 0)');

ctx.fillStyle = gradient;
ctx.beginPath();
ctx.arc(32, 32, 32, 0, Math.PI * 2);
ctx.fill();

const texture = new THREE.CanvasTexture(canvas);
texture.needsUpdate = true;
return texture;
}

class ParticleWaterSystem {
constructor() {
console.log('Creating circle particle water system...');
this.time = 0;
// 80x55 grid in water area only (z > -15)
this.gridSizeX = 80;
this.gridSizeZ = 55;
this.spacing = 1.8;
const total = this.gridSizeX * this.gridSizeZ;

const positions = new Float32Array(total * 3);
const colors = new Float32Array(total * 3);
const sizes = new Float32Array(total);

let idx = 0;
for (let gz = 0; gz < this.gridSizeZ; gz++) {
  for (let gx = 0; gx < this.gridSizeX; gx++) {
    const x = (gx - this.gridSizeX / 2) * this.spacing;
    // Z goes from -12 (near shore) to +85 (ocean)
    const z = -12 + gz * this.spacing;
    positions[idx * 3] = x;
    positions[idx * 3 + 1] = 0;
    positions[idx * 3 + 2] = z;
    
    // Varied blue colors based on position
    const depth = 0.5 + 0.5 * Math.sin(x * 0.03 + z * 0.02);
    colors[idx * 3] = 0.0 + depth * 0.1;
    colors[idx * 3 + 1] = 0.4 + depth * 0.3;
    colors[idx * 3 + 2] = 0.7 + depth * 0.3;
    
    // Varied sizes for depth
    sizes[idx] = 0.8 + Math.random() * 0.6;
    idx++;
  }
}

const geometry = new THREE.BufferGeometry();
geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

// Circle texture for disc particles
this.circleTexture = createCircleTexture();

const material = new THREE.PointsMaterial({
  size: 1.2,
  map: this.circleTexture,
  transparent: true,
  opacity: 0.88,
  vertexColors: true,
  sizeAttenuation: true,
  depthWrite: false,
  blending: THREE.NormalBlending,
  alphaTest: 0.01
});

this.points = new THREE.Points(geometry, material);
this.points.frustumCulled = false;
this.points.renderOrder = 1;
scene.add(this.points);
this.positionArray = positions;
this.colorArray = colors;

// Disturbance system for realistic water reactions
this.disturbances = [];
console.log(`Created ${total} circle water particles ‚úì`);
}

waveHeight(x, z, t) {
const k = CONFIG.waveIntensity;
const s = CONFIG.waveSpeed * t;
return (
  Math.sin(x * 0.04 + s) * k +
  Math.sin(z * 0.035 + s * 0.87) * k * 0.85 +
  Math.sin((x + z) * 0.025 + s * 1.1) * k * 0.6 +
  Math.sin(x * 0.08 - z * 0.03 + s * 0.7) * k * 0.4 +
  Math.sin((x - z) * 0.02 + s * 1.3) * k * 0.35 +
  Math.sin(x * 0.015 + z * 0.02 + s * 0.5) * k * 0.25
);
}

update(deltaTime) {
this.time += deltaTime;
const t = this.time;
const pos = this.positionArray;
const col = this.colorArray;
const gsX = this.gridSizeX;
const gsZ = this.gridSizeZ;

// Update disturbances
for (let i = this.disturbances.length - 1; i >= 0; i--) {
  this.disturbances[i].life -= deltaTime;
  if (this.disturbances[i].life <= 0) {
    this.disturbances.splice(i, 1);
  }
}

for (let gz = 0; gz < gsZ; gz++) {
  for (let gx = 0; gx < gsX; gx++) {
    const idx = (gz * gsX + gx);
    const x = pos[idx * 3];
    const z = pos[idx * 3 + 2];
    let h = this.waveHeight(x, z, t);
    
    // Apply disturbances from people/objects
    for (const d of this.disturbances) {
      const dx = x - d.x;
      const dz = z - d.z;
      const dist = Math.sqrt(dx * dx + dz * dz);
      if (dist < d.radius) {
        const falloff = 1 - dist / d.radius;
        const lifeRatio = d.life / d.maxLife;
        const ripple = Math.sin(dist * 3 - t * 8) * d.strength * falloff * lifeRatio;
        h += ripple;
      }
    }
    
    pos[idx * 3 + 1] = h;
    
    // Dynamic color based on wave height
    const heightFactor = (h + 3) / 6;
    col[idx * 3 + 1] = 0.35 + heightFactor * 0.25;
    col[idx * 3 + 2] = 0.6 + heightFactor * 0.3;
  }
}

this.points.geometry.attributes.position.needsUpdate = true;
this.points.geometry.attributes.color.needsUpdate = true;
}

getHeightAt(x, z) {
return this.waveHeight(x, z, this.time);
}

disturb(x, z, strength) {
// Add a disturbance that will affect nearby particles
this.disturbances.push({
  x: x,
  z: z,
  strength: strength,
  radius: 3 + strength * 2,
  life: 1.5, // seconds
  maxLife: 1.5
});
}

remove() {
scene.remove(this.points);
this.points.geometry.dispose();
this.points.material.dispose();
this.circleTexture.dispose();
}
}

// ==========================================
// MESH WATER SYSTEM WITH FOAM
// ==========================================

class MeshWaterSystem {
constructor() {
console.log('Creating mesh water system...');
this.time = 0;

// Water mesh - stops at shoreline (z = -15), extends to ocean (z = +90)
const w = 180, h = 105; // Width x Depth
const segsW = 120, segsH = 70;
const geometry = new THREE.PlaneGeometry(w, h, segsW, segsH);
geometry.rotateX(-Math.PI / 2);

// Shift geometry so it goes from z=-15 (shore) to z=+90 (ocean)
const positions = geometry.attributes.position.array;
for (let i = 0; i < positions.length; i += 3) {
  positions[i + 2] += 37.5; // Shift forward (ocean direction)
}
geometry.attributes.position.needsUpdate = true;

const material = new THREE.MeshPhongMaterial({
  color: 0x006699,
  emissive: 0x001525,
  specular: 0xaaddff,
  shininess: 150,
  transparent: true,
  opacity: 0.9,
  side: THREE.DoubleSide,
  depthWrite: true,
  flatShading: false
});

this.mesh = new THREE.Mesh(geometry, material);
this.mesh.position.set(0, -0.3, 0);
this.mesh.receiveShadow = true;
this.mesh.castShadow = true;
this.mesh.renderOrder = 0;
scene.add(this.mesh);

this.originalPositions = geometry.attributes.position.array.slice();

// Add vertex colors for foam
const colors = new Float32Array(geometry.attributes.position.count * 3);
for (let i = 0; i < colors.length; i += 3) {
  colors[i] = 0.0;
  colors[i + 1] = 0.4;
  colors[i + 2] = 0.6;
}
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
this.colorArray = colors;
material.vertexColors = true;

// Shore foam particles
this.createShoreFoam();

// Disturbance system for realistic water reactions
this.disturbances = [];

console.log('Mesh water created ‚úì');
}

createShoreFoam() {
// Foam line at shore (z = -15 to z = 5)
const foamCount = 1500;
const foamPositions = new Float32Array(foamCount * 3);
const foamSizes = new Float32Array(foamCount);

for (let i = 0; i < foamCount; i++) {
  foamPositions[i * 3] = (Math.random() - 0.5) * 140;
  foamPositions[i * 3 + 1] = 0.1;
  foamPositions[i * 3 + 2] = -12 + Math.random() * 15 + Math.sin(foamPositions[i * 3] * 0.1) * 3;
  foamSizes[i] = 0.25 + Math.random() * 0.4;
}

const foamGeo = new THREE.BufferGeometry();
foamGeo.setAttribute('position', new THREE.BufferAttribute(foamPositions, 3));
foamGeo.setAttribute('size', new THREE.BufferAttribute(foamSizes, 1));

// Create foam texture
const foamCanvas = document.createElement('canvas');
foamCanvas.width = 32;
foamCanvas.height = 32;
const ctx = foamCanvas.getContext('2d');
const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
gradient.addColorStop(0.5, 'rgba(240, 250, 255, 0.6)');
gradient.addColorStop(1, 'rgba(200, 230, 255, 0)');
ctx.fillStyle = gradient;
ctx.beginPath();
ctx.arc(16, 16, 16, 0, Math.PI * 2);
ctx.fill();
this.foamTexture = new THREE.CanvasTexture(foamCanvas);

const foamMat = new THREE.PointsMaterial({
  size: 0.6,
  map: this.foamTexture,
  transparent: true,
  opacity: 0.7,
  depthWrite: false,
  blending: THREE.AdditiveBlending
});

this.foam = new THREE.Points(foamGeo, foamMat);
this.foam.frustumCulled = false;
scene.add(this.foam);
this.foamPositions = foamPositions;
}

waveHeight(x, z, t) {
const k = CONFIG.waveIntensity;
const s = CONFIG.waveSpeed * t;

// Main swell
let h = Math.sin(x * 0.03 + s) * k * 1.2;
// Cross wave
h += Math.sin(z * 0.025 + s * 0.87) * k * 0.9;
// Chop
h += Math.sin((x + z) * 0.02 + s * 1.1) * k * 0.5;
h += Math.sin(x * 0.06 - z * 0.025 + s * 0.7) * k * 0.35;
// Fine detail
h += Math.sin((x - z) * 0.015 + s * 1.3) * k * 0.25;
h += Math.sin(x * 0.01 + z * 0.015 + s * 0.5) * k * 0.2;
// Microwave detail
h += Math.sin(x * 0.12 + s * 2) * k * 0.1;
h += Math.sin(z * 0.1 + s * 1.8) * k * 0.08;

// Shore wave effect (waves get taller near shore)
const shoreFactor = Math.max(0, 1 - (z + 30) / 60);
if (shoreFactor > 0) {
  h += Math.sin(x * 0.05 + s * 1.5) * shoreFactor * k * 0.8;
  h *= (1 + shoreFactor * 0.5);
}

return h;
}

update(deltaTime) {
this.time += deltaTime;
const positions = this.mesh.geometry.attributes.position.array;
const colors = this.colorArray;
const t = this.time;

// Update disturbances
for (let i = this.disturbances.length - 1; i >= 0; i--) {
  this.disturbances[i].life -= deltaTime;
  if (this.disturbances[i].life <= 0) {
    this.disturbances.splice(i, 1);
  }
}

for (let i = 0; i < positions.length / 3; i++) {
  const idx = i * 3;
  const x = this.originalPositions[idx];
  const z = this.originalPositions[idx + 2];
  let h = this.waveHeight(x, z, t);
  
  // Apply disturbances from people/objects
  for (const d of this.disturbances) {
    const dx = x - d.x;
    const dz = z - d.z;
    const dist = Math.sqrt(dx * dx + dz * dz);
    if (dist < d.radius) {
      const falloff = 1 - dist / d.radius;
      const lifeRatio = d.life / d.maxLife;
      const ripple = Math.sin(dist * 3 - t * 8) * d.strength * falloff * lifeRatio;
      h += ripple;
    }
  }
  
  positions[idx + 1] = h;
  
  // Dynamic water color based on depth and wave height
  const depthFactor = Math.max(0, Math.min(1, (z + 50) / 100));
  const heightFactor = (h + 3) / 6;
  
  // Deep blue in deep water, lighter near shore
  colors[idx] = 0.0 + depthFactor * 0.15 + heightFactor * 0.1;
  colors[idx + 1] = 0.3 + depthFactor * 0.25 + heightFactor * 0.15;
  colors[idx + 2] = 0.5 + depthFactor * 0.15 + heightFactor * 0.2;
  
  // Add foam color at wave peaks near shore
  if (z < 10 && h > CONFIG.waveIntensity * 0.7) {
    const foamAmount = Math.min(1, (h - CONFIG.waveIntensity * 0.7) * 2);
    colors[idx] = colors[idx] * (1 - foamAmount) + foamAmount * 0.95;
    colors[idx + 1] = colors[idx + 1] * (1 - foamAmount) + foamAmount * 0.98;
    colors[idx + 2] = colors[idx + 2] * (1 - foamAmount) + foamAmount * 1.0;
  }
}

this.mesh.geometry.attributes.position.needsUpdate = true;
this.mesh.geometry.attributes.color.needsUpdate = true;
this.mesh.geometry.computeVertexNormals();

// Update foam particles
if (this.foam) {
  const foamPos = this.foamPositions;
  for (let i = 0; i < foamPos.length / 3; i++) {
    const x = foamPos[i * 3];
    const z = foamPos[i * 3 + 2];
    foamPos[i * 3 + 1] = this.waveHeight(x, z, t) + 0.1 + Math.random() * 0.05;
    
    // Move foam with waves
    foamPos[i * 3 + 2] += Math.sin(t + x * 0.1) * 0.02;
    
    // Reset foam that drifts too far from shore
    if (foamPos[i * 3 + 2] < -15 || foamPos[i * 3 + 2] > 8) {
      foamPos[i * 3 + 2] = -10 + Math.random() * 15;
    }
  }
  this.foam.geometry.attributes.position.needsUpdate = true;
}
}

getHeightAt(x, z) {
return this.waveHeight(x, z, this.time);
}

disturb(x, z, strength) {
// Add a disturbance that will affect nearby vertices
this.disturbances.push({
  x: x,
  z: z,
  strength: strength,
  radius: 4 + strength * 3,
  life: 2,
  maxLife: 2
});
}

remove() {
scene.remove(this.mesh);
if (this.foam) {
  scene.remove(this.foam);
  this.foam.geometry.dispose();
  this.foam.material.dispose();
  this.foamTexture.dispose();
}
}
}

// ==========================================
// REALISTIC BEACH
// ==========================================

function createBeach() {
console.log('Creating realistic beach...');

// Main sand plane with subtle height variation
const sandGeo = new THREE.PlaneGeometry(220, 120, 64, 32);
sandGeo.rotateX(-Math.PI / 2);

// Add subtle dune variation
const sandPos = sandGeo.attributes.position.array;
for (let i = 0; i < sandPos.length; i += 3) {
  const x = sandPos[i];
  const z = sandPos[i + 2];
  // Subtle dunes
  sandPos[i + 1] = Math.sin(x * 0.05) * 0.3 + Math.sin(z * 0.08 + x * 0.03) * 0.2;
}
sandGeo.computeVertexNormals();

const sandMat = new THREE.MeshStandardMaterial({ 
  color: 0xe8d4b8, 
  roughness: 0.95,
  metalness: 0.0
});
const sand = new THREE.Mesh(sandGeo, sandMat);
sand.position.set(0, -0.6, -65);
sand.receiveShadow = true;
scene.add(sand);

// Wet sand near water
const wetSandGeo = new THREE.PlaneGeometry(200, 30, 32, 8);
wetSandGeo.rotateX(-Math.PI / 2);
const wetSandMat = new THREE.MeshStandardMaterial({ 
  color: 0xb8a088, 
  roughness: 0.6,
  metalness: 0.15
});
const wetSand = new THREE.Mesh(wetSandGeo, wetSandMat);
wetSand.position.set(0, -0.55, -22);
wetSand.receiveShadow = true;
scene.add(wetSand);

// Seabed with gradient depth
const seabedGeo = new THREE.PlaneGeometry(220, 220, 32, 32);
seabedGeo.rotateX(-Math.PI / 2);
const seabedPos = seabedGeo.attributes.position.array;
for (let i = 0; i < seabedPos.length; i += 3) {
  const z = seabedPos[i + 2];
  // Deeper further from shore
  seabedPos[i + 1] = -Math.max(2, 8 - z * 0.05);
}
seabedGeo.computeVertexNormals();
const seabedMat = new THREE.MeshStandardMaterial({ color: 0x6b5344, roughness: 0.9 });
const seabed = new THREE.Mesh(seabedGeo, seabedMat);
seabed.receiveShadow = true;
scene.add(seabed);

// Realistic palm trees with coconuts
const palmPositions = [
  [-55, 3.5, -58], [58, 3.5, -52], [-62, 3.5, -42], [45, 3.5, -62],
  [-35, 3.5, -68], [25, 3.5, -70], [-70, 3.5, -55], [68, 3.5, -48]
];
palmPositions.forEach(([x, y, z]) => {
  const palm = new THREE.Group();
  
  // Curved trunk (multiple segments)
  const trunkMat = new THREE.MeshStandardMaterial({ color: 0x7a5c34, roughness: 0.9 });
  const curve = 0.1 + Math.random() * 0.15;
  for (let i = 0; i < 5; i++) {
    const segGeo = new THREE.CylinderGeometry(0.25 - i * 0.03, 0.3 - i * 0.02, 1.6, 10);
    const seg = new THREE.Mesh(segGeo, trunkMat);
    seg.position.y = i * 1.5;
    seg.position.x = Math.sin(i * curve) * i * 0.2;
    seg.rotation.z = -curve * i * 0.15;
    seg.castShadow = true;
    seg.receiveShadow = true;
    palm.add(seg);
  }
  
  // Palm fronds (multiple leaves)
  const leavesMat = new THREE.MeshStandardMaterial({ color: 0x2d8c2d, roughness: 0.7, side: THREE.DoubleSide });
  for (let i = 0; i < 8; i++) {
    const angle = (i / 8) * Math.PI * 2;
    const leafGeo = new THREE.ConeGeometry(0.4, 4, 4);
    const leaf = new THREE.Mesh(leafGeo, leavesMat);
    leaf.position.set(
      Math.cos(angle) * 0.5 + Math.sin(4 * curve) * 0.8,
      7.5,
      Math.sin(angle) * 0.5
    );
    leaf.rotation.x = 0.8 + Math.random() * 0.3;
    leaf.rotation.y = angle;
    leaf.rotation.z = Math.random() * 0.2;
    leaf.castShadow = true;
    palm.add(leaf);
  }
  
  // Coconuts
  const coconutMat = new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 0.8 });
  for (let i = 0; i < 3; i++) {
    const coconutGeo = new THREE.SphereGeometry(0.15, 10, 8);
    const coconut = new THREE.Mesh(coconutGeo, coconutMat);
    coconut.position.set(
      Math.cos(i * 2.1) * 0.3 + Math.sin(4 * curve) * 0.8,
      7,
      Math.sin(i * 2.1) * 0.3
    );
    coconut.castShadow = true;
    palm.add(coconut);
  }
  
  palm.position.set(x, y, z);
  palm.rotation.y = Math.random() * Math.PI * 2;
  scene.add(palm);
  beachObjects.push(palm);
});

// Rocks
const rockPositions = [[-30, -0.2, -50], [25, -0.3, -52], [0, -0.4, -58], [-15, -0.2, -45]];
rockPositions.forEach(([x, y, z], i) => {
const rockGeo = new THREE.DodecahedronGeometry(0.8 + Math.random() * 0.8, 0);
const rockMat = new THREE.MeshStandardMaterial({ color: 0x6b6b6b, roughness: 0.95 });
const rock = new THREE.Mesh(rockGeo, rockMat);
rock.position.set(x, y, z);
rock.rotation.set(Math.random() * 0.3, Math.random() * Math.PI * 2, Math.random() * 0.2);
rock.scale.setScalar(0.8 + Math.random() * 0.6);
rock.castShadow = true;
rock.receiveShadow = true;
scene.add(rock);
beachObjects.push(rock);
});

console.log('Beach created ‚úì');
}

// ==========================================
// PERSON MODEL
// ==========================================

// Skin tone library (8 realistic tones)
const SKIN_TONES = [
{ name: 'fair', color: 0xffe4d4, specular: 0xfff0e8 },
{ name: 'light', color: 0xffd8c8, specular: 0xffe8dc },
{ name: 'medium-light', color: 0xe8c4a8, specular: 0xf0d4bc },
{ name: 'medium', color: 0xd4a074, specular: 0xe4b490 },
{ name: 'olive', color: 0xc8a882, specular: 0xd8bc98 },
{ name: 'tan', color: 0xb8885c, specular: 0xc8a078 },
{ name: 'brown', color: 0x8c6844, specular: 0xa07c58 },
{ name: 'dark', color: 0x5c4030, specular: 0x705444 }
];

// Hair colors
const HAIR_COLORS = [
0x1a1a1a, 0x2d1b0e, 0x4a3728, 0x6b4423, 0x8b6914,
0xa67c52, 0xc4956a, 0xe8b96d, 0xd4a574, 0x808080
];

// Swimwear colors
const SWIMWEAR_COLORS = [
0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf9ca24, 0xff8c42,
0x9b59b6, 0x2ecc71, 0xe74c3c, 0x3498db, 0x1abc9c,
0xf39c12, 0x8e44ad, 0x16a085, 0xd35400, 0x2c3e50
];

// Body types
const BODY_TYPES = [
{ name: 'athletic', torsoScale: [1, 1, 0.9], shoulderWidth: 1.1 },
{ name: 'average', torsoScale: [1, 1, 1], shoulderWidth: 1 },
{ name: 'slim', torsoScale: [0.85, 1.05, 0.85], shoulderWidth: 0.9 },
{ name: 'stocky', torsoScale: [1.15, 0.95, 1.1], shoulderWidth: 1.15 },
{ name: 'child', torsoScale: [0.7, 0.7, 0.7], shoulderWidth: 0.7 }
];

// 50+ Activity/Animation types
const ACTIVITY_TYPES = {
// Beach activities (on sand)
beach: [
  'standing', 'sitting', 'lying_back', 'lying_front', 'lying_side',
  'building_sandcastle', 'digging_sand', 'burying_friend', 'making_sand_angel',
  'sunbathing', 'reading_book', 'applying_sunscreen', 'stretching',
  'playing_frisbee', 'playing_volleyball', 'doing_pushups', 'doing_situps',
  'yoga_pose', 'meditating', 'taking_photo', 'waving', 'pointing',
  'walking_slow', 'walking_fast', 'jogging', 'running', 'sprinting',
  'jumping', 'hopping', 'skipping', 'dancing', 'hula_dance',
  'talking', 'laughing', 'eating', 'drinking', 'picking_shells',
  'building_moat', 'drawing_in_sand', 'kicking_sand', 'collecting_water'
],
// Water activities
water: [
  'wading', 'swimming', 'floating', 'treading_water', 'splashing',
  'diving', 'jumping_waves', 'bodyboarding', 'snorkeling',
  'playing_in_waves', 'ducking_under', 'standing_in_water', 'walking_in_water',
  'swimming_backstroke', 'swimming_breaststroke', 'doggy_paddle'
]
};

// Flat list for easy random selection
const ALL_BEACH_ACTIVITIES = ACTIVITY_TYPES.beach;
const ALL_WATER_ACTIVITIES = ACTIVITY_TYPES.water;

class HighPolyPerson {
constructor(position, options = {}) {
this.position = position.clone();
this.velocity = new THREE.Vector3();
this.direction = new THREE.Vector2(Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();
this.speed = 0.3 + Math.random() * 0.4;
this.time = Math.random() * 10;
this.changeTimer = 0;
this.animPhase = Math.random() * Math.PI * 2;

// Animation transition system
this.activityTimer = 0;
this.activityDuration = 3 + Math.random() * 12; // 3-15 seconds for more active movement
this.transitionProgress = 0;
this.isTransitioning = false;
this.previousActivity = null;

// Random characteristics
this.skinTone = options.skinTone || SKIN_TONES[Math.floor(Math.random() * SKIN_TONES.length)];
this.hairColor = options.hairColor || HAIR_COLORS[Math.floor(Math.random() * HAIR_COLORS.length)];
this.swimColor = options.swimColor || SWIMWEAR_COLORS[Math.floor(Math.random() * SWIMWEAR_COLORS.length)];
this.bodyType = options.bodyType || BODY_TYPES[Math.floor(Math.random() * BODY_TYPES.length)];
// Assign activity based on location - favor movement activities
if (this.position.z < -20) {
  // On beach - 60% chance of walking/movement
  if (Math.random() < 0.6) {
    const moveActivities = ['walking_slow', 'walking_fast', 'jogging', 'running', 'skipping'];
    this.activity = options.activity || moveActivities[Math.floor(Math.random() * moveActivities.length)];
  } else {
    this.activity = options.activity || ALL_BEACH_ACTIVITIES[Math.floor(Math.random() * ALL_BEACH_ACTIVITIES.length)];
  }
} else {
  // In water - 70% chance of swimming/moving
  if (Math.random() < 0.7) {
    const waterMoveActivities = ['swimming', 'wading', 'walking_in_water', 'splashing', 'playing_in_waves'];
    this.activity = options.activity || waterMoveActivities[Math.floor(Math.random() * waterMoveActivities.length)];
  } else {
    this.activity = options.activity || ALL_WATER_ACTIVITIES[Math.floor(Math.random() * ALL_WATER_ACTIVITIES.length)];
  }
}

this.isMale = Math.random() > 0.5;
this.isChild = this.bodyType.name === 'child';

// Sandcastle building state
this.buildingState = 0; // 0 = gathering, 1 = placing, 2 = patting
this.buildingProgress = 0;
this.mySandcastle = null;
this.bucket = null;

// Props
this.hasBook = false;
this.hasFrisbee = false;

this.limbRefs = {};
this.createMesh();

// Create bucket for sand activities
if (this.activity.includes('building') || this.activity.includes('digging') || this.activity.includes('collecting')) {
  this.createBucket();
  this.createPersonalSandcastle();
}
}

createBucket() {
const bucketGroup = new THREE.Group();
const bucketMat = new THREE.MeshStandardMaterial({ color: [0xff6b6b, 0x4ecdc4, 0xf9ca24, 0x45b7d1][Math.floor(Math.random() * 4)], roughness: 0.5 });

// Bucket body
const bucketGeo = new THREE.CylinderGeometry(0.08, 0.06, 0.12, 12);
const bucket = new THREE.Mesh(bucketGeo, bucketMat);
bucket.castShadow = true;
bucketGroup.add(bucket);

// Handle
const handleGeo = new THREE.TorusGeometry(0.05, 0.008, 8, 16, Math.PI);
const handleMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.5 });
const handle = new THREE.Mesh(handleGeo, handleMat);
handle.position.y = 0.06;
handle.rotation.x = Math.PI;
bucketGroup.add(handle);

// Sand in bucket
const sandGeo = new THREE.CylinderGeometry(0.07, 0.07, 0.04, 12);
const sandMat = new THREE.MeshStandardMaterial({ color: 0xd4b896, roughness: 0.95 });
this.bucketSand = new THREE.Mesh(sandGeo, sandMat);
this.bucketSand.position.y = 0.04;
this.bucketSand.visible = false;
bucketGroup.add(this.bucketSand);

bucketGroup.position.set(0.35, 0, 0.2);
this.bucket = bucketGroup;
this.mesh.add(bucketGroup);
}

createPersonalSandcastle() {
const castleGroup = new THREE.Group();
const sandMat = new THREE.MeshStandardMaterial({ color: 0xd4b896, roughness: 0.95 });

// Start with just a mound, grows as they build
const moundGeo = new THREE.ConeGeometry(0.15, 0.1, 12);
const mound = new THREE.Mesh(moundGeo, sandMat);
mound.position.y = 0.05;
mound.castShadow = true;
castleGroup.add(mound);
this.castleMound = mound;

// Tower (hidden initially, appears as building progresses)
const towerGeo = new THREE.CylinderGeometry(0.08, 0.1, 0.2, 10);
const tower = new THREE.Mesh(towerGeo, sandMat);
tower.position.y = 0.15;
tower.scale.y = 0;
tower.castShadow = true;
castleGroup.add(tower);
this.castleTower = tower;

// Top
const topGeo = new THREE.ConeGeometry(0.1, 0.1, 10);
const top = new THREE.Mesh(topGeo, sandMat);
top.position.y = 0.3;
top.scale.y = 0;
top.castShadow = true;
castleGroup.add(top);
this.castleTop = top;

castleGroup.position.set(0.5, -0.6, 0.4);
this.mySandcastle = castleGroup;
scene.add(castleGroup);
}

createMesh() {
const group = new THREE.Group();
const bt = this.bodyType;
const scale = this.isChild ? 0.6 : 1;

// Materials
const skinMat = new THREE.MeshStandardMaterial({
  color: this.skinTone.color,
  roughness: 0.7,
  metalness: 0.02
});

const hairMat = new THREE.MeshStandardMaterial({
  color: this.hairColor,
  roughness: 0.85,
  metalness: 0.0
});

const swimMat = new THREE.MeshStandardMaterial({
  color: this.swimColor,
  roughness: 0.4,
  metalness: 0.05
});

// ========== TORSO (high poly) ==========
// Upper torso / chest
const chestGeo = new THREE.CylinderGeometry(0.22 * bt.shoulderWidth, 0.2, 0.35, 16, 3);
const chest = new THREE.Mesh(chestGeo, skinMat);
chest.position.y = 0.35;
chest.scale.set(bt.torsoScale[0], bt.torsoScale[1], bt.torsoScale[2]);
chest.castShadow = true;
chest.receiveShadow = true;
group.add(chest);

// Lower torso / abdomen
const abdomenGeo = new THREE.CylinderGeometry(0.18, 0.2, 0.25, 16, 2);
const abdomen = new THREE.Mesh(abdomenGeo, skinMat);
abdomen.position.y = 0.12;
abdomen.scale.set(bt.torsoScale[0], 1, bt.torsoScale[2]);
abdomen.castShadow = true;
abdomen.receiveShadow = true;
group.add(abdomen);

// Hips
const hipsGeo = new THREE.SphereGeometry(0.2, 16, 12, 0, Math.PI * 2, 0, Math.PI * 0.6);
const hips = new THREE.Mesh(hipsGeo, skinMat);
hips.position.y = -0.02;
hips.scale.set(bt.torsoScale[0] * 1.1, 0.6, bt.torsoScale[2]);
hips.castShadow = true;
group.add(hips);

// ========== HEAD (high poly - 196+ faces) ==========
const headGeo = new THREE.SphereGeometry(0.16, 20, 16);
const head = new THREE.Mesh(headGeo, skinMat);
head.position.y = 0.62;
head.scale.set(1, 1.1, 0.95);
head.castShadow = true;
head.receiveShadow = true;
group.add(head);

// Neck
const neckGeo = new THREE.CylinderGeometry(0.06, 0.08, 0.1, 12);
const neck = new THREE.Mesh(neckGeo, skinMat);
neck.position.y = 0.52;
neck.castShadow = true;
group.add(neck);

// Face features
// Nose
const noseGeo = new THREE.ConeGeometry(0.025, 0.06, 8);
const nose = new THREE.Mesh(noseGeo, skinMat);
nose.position.set(0, 0.6, 0.14);
nose.rotation.x = Math.PI * 0.6;
group.add(nose);

// Eyes
const eyeWhiteGeo = new THREE.SphereGeometry(0.025, 10, 8);
const eyeWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1 });
const eyeL = new THREE.Mesh(eyeWhiteGeo, eyeWhiteMat);
eyeL.position.set(-0.05, 0.64, 0.12);
eyeL.scale.set(1, 0.7, 0.5);
group.add(eyeL);
const eyeR = eyeL.clone();
eyeR.position.x = 0.05;
group.add(eyeR);

// Pupils
const pupilGeo = new THREE.SphereGeometry(0.012, 8, 8);
const pupilMat = new THREE.MeshStandardMaterial({ color: 0x3d2314, roughness: 0.2 });
const pupilL = new THREE.Mesh(pupilGeo, pupilMat);
pupilL.position.set(-0.05, 0.64, 0.135);
group.add(pupilL);
const pupilR = pupilL.clone();
pupilR.position.x = 0.05;
group.add(pupilR);

// Ears
const earGeo = new THREE.SphereGeometry(0.04, 8, 8);
const earL = new THREE.Mesh(earGeo, skinMat);
earL.position.set(-0.15, 0.6, 0);
earL.scale.set(0.4, 0.7, 0.5);
group.add(earL);
const earR = earL.clone();
earR.position.x = 0.15;
group.add(earR);

// Mouth
const mouthGeo = new THREE.TorusGeometry(0.03, 0.008, 8, 12, Math.PI);
const mouthMat = new THREE.MeshStandardMaterial({ color: 0xcc7777, roughness: 0.3 });
const mouth = new THREE.Mesh(mouthGeo, mouthMat);
mouth.position.set(0, 0.55, 0.12);
mouth.rotation.x = Math.PI * 0.1;
mouth.rotation.z = Math.PI;
group.add(mouth);

// ========== HAIR (varied styles) ==========
const hairStyle = Math.floor(Math.random() * 4);
if (hairStyle === 0) {
  // Short hair
  const shortHairGeo = new THREE.SphereGeometry(0.17, 16, 12, 0, Math.PI * 2, 0, Math.PI * 0.55);
  const shortHair = new THREE.Mesh(shortHairGeo, hairMat);
  shortHair.position.y = 0.68;
  shortHair.scale.set(1, 0.9, 0.95);
  shortHair.castShadow = true;
  group.add(shortHair);
} else if (hairStyle === 1) {
  // Long hair
  const longHairGeo = new THREE.CylinderGeometry(0.16, 0.12, 0.4, 16, 4);
  const longHair = new THREE.Mesh(longHairGeo, hairMat);
  longHair.position.set(0, 0.5, -0.05);
  longHair.castShadow = true;
  group.add(longHair);
  const topHairGeo = new THREE.SphereGeometry(0.165, 14, 10, 0, Math.PI * 2, 0, Math.PI * 0.6);
  const topHair = new THREE.Mesh(topHairGeo, hairMat);
  topHair.position.y = 0.68;
  topHair.castShadow = true;
  group.add(topHair);
} else if (hairStyle === 2) {
  // Curly/afro
  const afroGeo = new THREE.SphereGeometry(0.22, 16, 14);
  const afro = new THREE.Mesh(afroGeo, hairMat);
  afro.position.y = 0.7;
  afro.scale.set(1, 0.85, 0.9);
  afro.castShadow = true;
  group.add(afro);
} else {
  // Bald/very short
  const buzzGeo = new THREE.SphereGeometry(0.162, 14, 10, 0, Math.PI * 2, 0, Math.PI * 0.45);
  const buzz = new THREE.Mesh(buzzGeo, hairMat);
  buzz.position.y = 0.67;
  buzz.castShadow = true;
  group.add(buzz);
}

// ========== ARMS (properly jointed) ==========
// Shoulders (connection points)
const shoulderGeo = new THREE.SphereGeometry(0.06, 10, 8);
const shoulderL = new THREE.Mesh(shoulderGeo, skinMat);
shoulderL.position.set(-0.24 * bt.shoulderWidth, 0.38, 0);
shoulderL.castShadow = true;
group.add(shoulderL);

const shoulderR = new THREE.Mesh(shoulderGeo, skinMat);
shoulderR.position.set(0.24 * bt.shoulderWidth, 0.38, 0);
shoulderR.castShadow = true;
group.add(shoulderR);

// Upper arms (attached to shoulders)
const upperArmGeo = new THREE.CylinderGeometry(0.05, 0.055, 0.25, 10);
const upperArmL = new THREE.Mesh(upperArmGeo, skinMat);
upperArmL.position.set(-0.28 * bt.shoulderWidth, 0.24, 0);
upperArmL.rotation.z = 0.15;
upperArmL.castShadow = true;
group.add(upperArmL);
this.limbRefs.upperArmL = upperArmL;

const upperArmR = new THREE.Mesh(upperArmGeo, skinMat);
upperArmR.position.set(0.28 * bt.shoulderWidth, 0.24, 0);
upperArmR.rotation.z = -0.15;
upperArmR.castShadow = true;
group.add(upperArmR);
this.limbRefs.upperArmR = upperArmR;

// Elbows
const elbowGeo = new THREE.SphereGeometry(0.045, 8, 6);
const elbowL = new THREE.Mesh(elbowGeo, skinMat);
elbowL.position.set(-0.30 * bt.shoulderWidth, 0.10, 0);
elbowL.castShadow = true;
group.add(elbowL);

const elbowR = new THREE.Mesh(elbowGeo, skinMat);
elbowR.position.set(0.30 * bt.shoulderWidth, 0.10, 0);
elbowR.castShadow = true;
group.add(elbowR);

// Forearms
const forearmGeo = new THREE.CylinderGeometry(0.04, 0.05, 0.22, 10);
const forearmL = new THREE.Mesh(forearmGeo, skinMat);
forearmL.position.set(-0.30 * bt.shoulderWidth, -0.02, 0);
forearmL.castShadow = true;
group.add(forearmL);
this.limbRefs.forearmL = forearmL;

const forearmR = new THREE.Mesh(forearmGeo, skinMat);
forearmR.position.set(0.30 * bt.shoulderWidth, -0.02, 0);
forearmR.castShadow = true;
group.add(forearmR);
this.limbRefs.forearmR = forearmR;

// Wrists
const wristGeo = new THREE.SphereGeometry(0.035, 8, 6);
const wristL = new THREE.Mesh(wristGeo, skinMat);
wristL.position.set(-0.30 * bt.shoulderWidth, -0.14, 0);
group.add(wristL);

const wristR = new THREE.Mesh(wristGeo, skinMat);
wristR.position.set(0.30 * bt.shoulderWidth, -0.14, 0);
group.add(wristR);

// Hands (more detailed)
const handGeo = new THREE.BoxGeometry(0.07, 0.09, 0.035, 2, 2, 1);
const handL = new THREE.Mesh(handGeo, skinMat);
handL.position.set(-0.30 * bt.shoulderWidth, -0.20, 0);
handL.castShadow = true;
group.add(handL);

const handR = new THREE.Mesh(handGeo, skinMat);
handR.position.set(0.30 * bt.shoulderWidth, -0.20, 0);
handR.castShadow = true;
group.add(handR);

// ========== LEGS (high poly with feet) ==========
// Upper legs / thighs
const thighGeo = new THREE.CylinderGeometry(0.07, 0.085, 0.32, 14, 2);
const thighL = new THREE.Mesh(thighGeo, skinMat);
thighL.position.set(-0.09, -0.2, 0);
thighL.rotation.x = 0.05;
thighL.castShadow = true;
group.add(thighL);
this.limbRefs.thighL = thighL;

const thighR = new THREE.Mesh(thighGeo, skinMat);
thighR.position.set(0.09, -0.2, 0);
thighR.rotation.x = 0.05;
thighR.castShadow = true;
group.add(thighR);
this.limbRefs.thighR = thighR;

// Lower legs / calves
const calfGeo = new THREE.CylinderGeometry(0.045, 0.06, 0.3, 12, 2);
const calfL = new THREE.Mesh(calfGeo, skinMat);
calfL.position.set(-0.09, -0.5, 0.02);
calfL.castShadow = true;
group.add(calfL);
this.limbRefs.calfL = calfL;

const calfR = new THREE.Mesh(calfGeo, skinMat);
calfR.position.set(0.09, -0.5, 0.02);
calfR.castShadow = true;
group.add(calfR);
this.limbRefs.calfR = calfR;

// Feet
const footGeo = new THREE.BoxGeometry(0.06, 0.04, 0.12, 2, 1, 2);
const footL = new THREE.Mesh(footGeo, skinMat);
footL.position.set(-0.09, -0.67, 0.04);
footL.castShadow = true;
group.add(footL);

const footR = new THREE.Mesh(footGeo, skinMat);
footR.position.set(0.09, -0.67, 0.04);
footR.castShadow = true;
group.add(footR);

// ========== SWIMWEAR ==========
if (this.isMale) {
  // Swim trunks
  const trunksGeo = new THREE.CylinderGeometry(0.19, 0.2, 0.18, 14, 2);
  const trunks = new THREE.Mesh(trunksGeo, swimMat);
  trunks.position.y = -0.04;
  trunks.castShadow = true;
  group.add(trunks);
} else {
  // Bikini top
  const bikiniTopGeo = new THREE.SphereGeometry(0.06, 10, 8);
  const bikiniL = new THREE.Mesh(bikiniTopGeo, swimMat);
  bikiniL.position.set(-0.08, 0.3, 0.1);
  bikiniL.scale.set(1, 0.8, 0.6);
  bikiniL.castShadow = true;
  group.add(bikiniL);
  const bikiniR = bikiniL.clone();
  bikiniR.position.x = 0.08;
  group.add(bikiniR);
  
  // Bikini bottom
  const bikiniBottomGeo = new THREE.CylinderGeometry(0.17, 0.18, 0.12, 12, 1);
  const bikiniBottom = new THREE.Mesh(bikiniBottomGeo, swimMat);
  bikiniBottom.position.y = -0.04;
  bikiniBottom.castShadow = true;
  group.add(bikiniBottom);
}

// Apply activity pose
this.applyPose(group);

group.position.copy(this.position);
group.scale.setScalar(scale * 1.3);
group.visible = true;
scene.add(group);
this.mesh = group;
}

// Get pose data for activity
getPoseForActivity(activity) {
const poses = {
  // Standing poses
  standing: { body: 0, armL: 0, armR: 0, legL: 0, legR: 0 },
  waving: { body: 0, armL: 0, armR: -1.5, legL: 0, legR: 0 },
  pointing: { body: 0, armL: 0, armR: -0.8, legL: 0, legR: 0 },
  talking: { body: 0, armL: 0.2, armR: 0.3, legL: 0, legR: 0 },
  laughing: { body: 0.1, armL: 0.3, armR: 0.3, legL: 0, legR: 0 },
  
  // Sitting poses
  sitting: { body: 0, armL: 0, armR: 0, legL: -1.5, legR: -1.5, kneeBend: 1.2, lower: 0.3 },
  meditating: { body: 0, armL: 0.5, armR: 0.5, legL: -1.5, legR: -1.5, kneeBend: 1.2, lower: 0.3 },
  sunbathing: { body: 0, armL: -0.3, armR: -0.3, legL: -1.5, legR: -1.5, kneeBend: 1.2, lower: 0.3 },
  reading_book: { body: 0.2, armL: -0.7, armR: -0.7, legL: -1.5, legR: -1.5, kneeBend: 1.2, lower: 0.3 },
  eating: { body: 0.15, armL: -0.8, armR: -0.8, legL: -1.5, legR: -1.5, kneeBend: 1.2, lower: 0.3 },
  drinking: { body: 0, armL: 0, armR: -1.2, legL: -1.5, legR: -1.5, kneeBend: 1.2, lower: 0.3 },
  taking_photo: { body: 0, armL: -0.7, armR: -0.7, legL: 0, legR: 0 },
  
  // Lying poses  
  lying_back: { bodyRotX: -1.5, lower: 0.5 },
  lying_front: { bodyRotX: 1.5, lower: 0.5 },
  lying_side: { bodyRotX: -1.5, bodyRotZ: 1.5, lower: 0.5 },
  making_sand_angel: { bodyRotX: -1.5, armL: -1.2, armR: -1.2, lower: 0.5 },
  
  // Kneeling/building poses
  building_sandcastle: { body: 0.3, armL: -0.6, armR: -0.6, legL: -1.5, legR: -1.5, kneeBend: 1.2, lower: 0.35 },
  digging_sand: { body: 0.5, armL: -0.8, armR: -0.8, legL: -1.5, legR: -1.5, kneeBend: 1.2, lower: 0.35 },
  burying_friend: { body: 0.4, armL: -0.7, armR: -0.7, legL: -1.5, legR: -1.5, kneeBend: 1.2, lower: 0.35 },
  picking_shells: { body: 0.6, armL: -0.9, armR: -0.9, legL: -0.3, legR: -0.3, lower: 0.2 },
  building_moat: { body: 0.5, armL: -0.7, armR: -0.7, legL: -1.5, legR: -1.5, kneeBend: 1.2, lower: 0.35 },
  drawing_in_sand: { body: 0.4, armL: 0, armR: -0.9, legL: -1.2, legR: -1.2, kneeBend: 1.0, lower: 0.3 },
  collecting_water: { body: 0.3, armL: -0.5, armR: -0.5, legL: 0, legR: 0 },
  applying_sunscreen: { body: 0, armL: -0.6, armR: -0.6, legL: 0, legR: 0 },
  
  // Exercise poses
  stretching: { body: -0.2, armL: -2.5, armR: -2.5, legL: 0, legR: 0 },
  yoga_pose: { body: 0, armL: -2.5, armR: -2.5, legL: 0, legR: 0.8 },
  doing_pushups: { bodyRotX: 1.4, armL: -0.8, armR: -0.8, lower: 0.5 },
  doing_situps: { bodyRotX: -0.8, armL: 0.5, armR: 0.5, legL: -0.8, legR: -0.8, lower: 0.4 },
  
  // Play poses
  playing_frisbee: { body: 0, armL: 0, armR: -1.2, legL: 0.2, legR: -0.2 },
  playing_volleyball: { body: 0, armL: -1.5, armR: -1.5, legL: 0.1, legR: -0.1 },
  kicking_sand: { body: 0, armL: 0.2, armR: 0.2, legL: 0, legR: 0.8 },
  
  // Water poses
  wading: { body: 0, armL: 0.2, armR: 0.2, legL: 0.2, legR: -0.2 },
  standing_in_water: { body: 0, armL: 0.3, armR: 0.3, legL: 0, legR: 0 },
  walking_in_water: { body: 0, armL: 0.2, armR: 0.2, legL: 0.3, legR: -0.3 },
  splashing: { body: 0.1, armL: -0.8, armR: -0.8, legL: 0.2, legR: 0.2 },
  swimming: { bodyRotX: 1.3, armL: -1.2, armR: 0.5, legL: 0.3, legR: -0.3, lower: 0.3 },
  swimming_backstroke: { bodyRotX: -1.3, armL: 0.5, armR: -1.2, legL: 0.3, legR: -0.3, lower: 0.3 },
  swimming_breaststroke: { bodyRotX: 1.2, armL: -0.8, armR: -0.8, legL: 0.5, legR: 0.5, lower: 0.3 },
  doggy_paddle: { bodyRotX: 1.0, armL: -0.6, armR: -0.6, legL: 0.2, legR: -0.2, lower: 0.4 },
  floating: { bodyRotX: -1.4, armL: -0.5, armR: -0.5, legL: 0.2, legR: 0.2, lower: 0.2 },
  treading_water: { body: 0, armL: -0.6, armR: -0.6, legL: 0.4, legR: -0.4 },
  diving: { bodyRotX: 1.5, armL: -2.5, armR: -2.5, legL: 0, legR: 0, lower: 0.5 },
  jumping_waves: { body: 0, armL: -0.5, armR: -0.5, legL: 0, legR: 0 },
  playing_in_waves: { body: 0.1, armL: -0.4, armR: -0.4, legL: 0.2, legR: -0.2 },
  ducking_under: { body: 0.8, armL: 0, armR: 0, legL: -0.5, legR: -0.5, lower: 0.4 },
  bodyboarding: { bodyRotX: 1.2, armL: -0.3, armR: -0.3, legL: 0.2, legR: 0.2, lower: 0.4 },
  snorkeling: { bodyRotX: 1.4, armL: 0.3, armR: 0.3, legL: 0.2, legR: -0.2, lower: 0.3 },
  
  // Dance/movement poses
  dancing: { body: 0.1, armL: -1.0, armR: -1.0, legL: 0.2, legR: -0.2 },
  hula_dance: { body: 0.1, armL: -0.8, armR: -0.6, legL: 0.15, legR: -0.15 },
  jumping: { body: 0, armL: -1.2, armR: -1.2, legL: 0, legR: 0 },
  hopping: { body: 0, armL: 0.3, armR: 0.3, legL: 0.5, legR: 0.5 },
  skipping: { body: 0, armL: 0.4, armR: -0.4, legL: 0.6, legR: -0.3 }
};

return poses[activity] || poses.standing;
}

applyPose(group) {
const pose = this.getPoseForActivity(this.activity);

// Apply body rotation
if (pose.bodyRotX) group.rotation.x = pose.bodyRotX;
if (pose.bodyRotZ) group.rotation.z = pose.bodyRotZ;

// Lower body for sitting/lying
if (pose.lower) group.position.y -= pose.lower;

// Apply leg poses
if (pose.legL !== undefined && this.limbRefs.thighL) {
  this.limbRefs.thighL.rotation.x = pose.legL;
}
if (pose.legR !== undefined && this.limbRefs.thighR) {
  this.limbRefs.thighR.rotation.x = pose.legR;
}

// Knee bend for sitting
if (pose.kneeBend) {
  if (this.limbRefs.calfL) {
    this.limbRefs.calfL.rotation.x = pose.kneeBend;
    this.limbRefs.calfL.position.y = -0.32;
    this.limbRefs.calfL.position.z = 0.25;
  }
  if (this.limbRefs.calfR) {
    this.limbRefs.calfR.rotation.x = pose.kneeBend;
    this.limbRefs.calfR.position.y = -0.32;
    this.limbRefs.calfR.position.z = 0.25;
  }
}

// Apply arm poses
if (pose.armL !== undefined && this.limbRefs.upperArmL) {
  this.limbRefs.upperArmL.rotation.x = pose.armL;
}
if (pose.armR !== undefined && this.limbRefs.upperArmR) {
  this.limbRefs.upperArmR.rotation.x = pose.armR;
}
}

// Change to a new random activity
changeActivity() {
this.previousActivity = this.activity;

// Pick new activity based on location
const inWater = this.position.z > -18;
const activityList = inWater ? ALL_WATER_ACTIVITIES : ALL_BEACH_ACTIVITIES;

// Pick a different activity
let newActivity;
do {
  newActivity = activityList[Math.floor(Math.random() * activityList.length)];
} while (newActivity === this.activity && activityList.length > 1);

this.activity = newActivity;
this.activityDuration = 3 + Math.random() * 12; // 3-15 seconds for more active movement
this.activityTimer = 0;
this.buildingState = 0;
this.buildingProgress = 0;

// Reset pose
this.mesh.rotation.set(0, this.mesh.rotation.y, 0);
this.mesh.position.y = this.position.y;

// Re-apply new pose
this.applyPose(this.mesh);

// Create bucket if needed for new activity
if ((this.activity.includes('building') || this.activity.includes('digging') || this.activity.includes('collecting')) && !this.bucket) {
  this.createBucket();
  this.createPersonalSandcastle();
}
}

update(deltaTime) {
this.time += deltaTime * 2;
this.changeTimer += deltaTime;
this.animPhase += deltaTime * 4;
this.activityTimer += deltaTime;

// ========== ALWAYS-ON IDLE ANIMATIONS (makes people look alive) ==========
// These subtle animations run constantly regardless of activity

// Breathing animation - subtle chest/torso movement
const breathCycle = Math.sin(this.time * 1.2);
const breathAmount = 0.015;

// Weight shifting - subtle body sway  
const swayCycle = Math.sin(this.time * 0.4 + this.animPhase);
const swayAmount = 0.02;

// Head micro-movements - looking around subtly
const headLookX = Math.sin(this.time * 0.3 + this.position.x) * 0.08;
const headLookY = Math.sin(this.time * 0.5 + this.position.z) * 0.06;

// Subtle fidgeting/twitching
const fidgetCycle = Math.sin(this.time * 3 + this.animPhase * 2);
const fidgetAmount = 0.02;

// Apply breathing - scale torso slightly
if (this.mesh) {
  // Subtle breathing motion on Y scale
  this.mesh.scale.y = (this.isChild ? 0.6 : 1) * 1.3 * (1 + breathCycle * breathAmount);
}

// Apply subtle swaying/weight shift (not during movement or lying down)
const lyingPoses = ['lying_back', 'lying_front', 'lying_side', 'making_sand_angel', 'floating', 
  'swimming', 'swimming_backstroke', 'swimming_breaststroke', 'snorkeling', 'bodyboarding', 
  'doggy_paddle', 'doing_pushups', 'doing_situps'];
const notLying = !lyingPoses.includes(this.activity);

if (notLying) {
  // Subtle body sway
  this.mesh.rotation.z = swayCycle * swayAmount;
  
  // Random occasional larger movements (scratching, adjusting, etc.)
  if (Math.random() < 0.001) {
    // Occasional head turn
    this.mesh.rotation.y += (Math.random() - 0.5) * 0.3;
  }
}

// Arm micro-fidgeting (when not doing specific arm activities)
const armActivities = ['swimming', 'waving', 'stretching', 'dancing', 'hula_dance', 
  'building_sandcastle', 'digging_sand', 'playing_frisbee', 'playing_volleyball',
  'doing_pushups', 'splashing', 'treading_water'];
const canFidgetArms = !armActivities.includes(this.activity);

if (canFidgetArms && this.limbRefs.upperArmL && this.limbRefs.upperArmR) {
  // Subtle arm swinging/adjustment
  this.limbRefs.upperArmL.rotation.z = (this.limbRefs.upperArmL.rotation.z || 0) + fidgetCycle * fidgetAmount * 0.5;
  this.limbRefs.upperArmR.rotation.z = (this.limbRefs.upperArmR.rotation.z || 0) - fidgetCycle * fidgetAmount * 0.5;
}

// Subtle knee bend variation for standing poses
const standingPoses = ['standing', 'standing_in_water', 'waving', 'pointing', 'talking', 'laughing', 'taking_photo'];
if (standingPoses.includes(this.activity)) {
  if (this.limbRefs.thighL) {
    this.limbRefs.thighL.rotation.x += Math.sin(this.time * 0.8) * 0.02;
  }
  if (this.limbRefs.thighR) {
    this.limbRefs.thighR.rotation.x += Math.sin(this.time * 0.8 + 1) * 0.02;
  }
}

// Random blinking simulation (head nod)
if (Math.random() < 0.002) {
  // Quick head dip for "blink"
  setTimeout(() => {
    if (this.mesh) this.mesh.rotation.x += 0.05;
  }, 0);
  setTimeout(() => {
    if (this.mesh) this.mesh.rotation.x -= 0.05;
  }, 100);
}

// ========== ACTIVITY-SPECIFIC ANIMATIONS ==========
if (!CONFIG.animatePeople) return;

// Check if time to change activity (5-60 seconds)
if (this.activityTimer >= this.activityDuration) {
  this.changeActivity();
}

const cycle = Math.sin(this.animPhase);
const fastCycle = Math.sin(this.animPhase * 2);
const slowCycle = Math.sin(this.animPhase * 0.5);

// Movement activities
const movementActivities = ['walking_slow', 'walking_fast', 'jogging', 'running', 'sprinting', 'skipping', 'hopping', 'wading', 'walking_in_water'];
const isMoving = movementActivities.includes(this.activity);

if (isMoving) {
  // Walking/running animation with speed variation
  let speedMult = 1;
  if (this.activity === 'walking_slow') speedMult = 0.5;
  else if (this.activity === 'walking_fast') speedMult = 1.2;
  else if (this.activity === 'jogging') speedMult = 1.8;
  else if (this.activity === 'running') speedMult = 2.5;
  else if (this.activity === 'sprinting') speedMult = 3.5;
  else if (this.activity === 'wading' || this.activity === 'walking_in_water') speedMult = 0.4;
  
  const walkCycle = Math.sin(this.animPhase * speedMult);
  if (this.limbRefs.thighL) this.limbRefs.thighL.rotation.x = walkCycle * 0.4 * speedMult;
  if (this.limbRefs.thighR) this.limbRefs.thighR.rotation.x = -walkCycle * 0.4 * speedMult;
  if (this.limbRefs.upperArmL) this.limbRefs.upperArmL.rotation.x = -walkCycle * 0.3 * speedMult;
  if (this.limbRefs.upperArmR) this.limbRefs.upperArmR.rotation.x = walkCycle * 0.3 * speedMult;
  
  // Direction change
  if (this.changeTimer > 4) {
    this.changeTimer = 0;
    this.direction = new THREE.Vector2(Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();
  }
  
  const moveSpeed = this.speed * speedMult * 0.5;
  this.velocity.x = this.direction.x * moveSpeed;
  this.velocity.z = this.direction.y * moveSpeed;
  this.position.x += this.velocity.x * deltaTime;
  this.position.z += this.velocity.z * deltaTime;
  
  // Keep in bounds
  const inWater = this.position.z > -18;
  if (Math.abs(this.position.x) > 70) {
    this.position.x = Math.sign(this.position.x) * 70;
    this.direction.x *= -1;
  }
  if (inWater) {
    if (this.position.z > 50 || this.position.z < -15) {
      this.position.z = Math.max(-15, Math.min(50, this.position.z));
      this.direction.y *= -1;
    }
  } else {
    if (this.position.z > -20 || this.position.z < -55) {
      this.position.z = Math.max(-55, Math.min(-20, this.position.z));
      this.direction.y *= -1;
    }
  }
  
  if (this.velocity.length() > 0.05) {
    const angle = Math.atan2(this.velocity.x, this.velocity.z);
    this.mesh.rotation.y = angle;
  }
}

// Dancing animations
if (this.activity === 'dancing' || this.activity === 'hula_dance') {
  if (this.limbRefs.upperArmL) this.limbRefs.upperArmL.rotation.x = -1.0 + cycle * 0.4;
  if (this.limbRefs.upperArmR) this.limbRefs.upperArmR.rotation.x = -1.0 - cycle * 0.4;
  if (this.limbRefs.thighL) this.limbRefs.thighL.rotation.x = cycle * 0.15;
  if (this.limbRefs.thighR) this.limbRefs.thighR.rotation.x = -cycle * 0.15;
  this.mesh.rotation.y += deltaTime * (this.activity === 'hula_dance' ? 0.3 : 0.5);
}

// Swimming animations
if (this.activity === 'swimming' || this.activity === 'swimming_backstroke' || this.activity === 'swimming_breaststroke') {
  if (this.limbRefs.upperArmL) this.limbRefs.upperArmL.rotation.x = -1.2 + cycle * 1.0;
  if (this.limbRefs.upperArmR) this.limbRefs.upperArmR.rotation.x = 0.5 - cycle * 1.0;
  if (this.limbRefs.thighL) this.limbRefs.thighL.rotation.x = fastCycle * 0.3;
  if (this.limbRefs.thighR) this.limbRefs.thighR.rotation.x = -fastCycle * 0.3;
  // Move through water
  this.position.x += Math.sin(this.mesh.rotation.y) * deltaTime * 0.5;
  this.position.z += Math.cos(this.mesh.rotation.y) * deltaTime * 0.5;
}

// Treading water
if (this.activity === 'treading_water') {
  if (this.limbRefs.upperArmL) this.limbRefs.upperArmL.rotation.x = -0.6 + cycle * 0.3;
  if (this.limbRefs.upperArmR) this.limbRefs.upperArmR.rotation.x = -0.6 - cycle * 0.3;
  if (this.limbRefs.thighL) this.limbRefs.thighL.rotation.x = fastCycle * 0.4;
  if (this.limbRefs.thighR) this.limbRefs.thighR.rotation.x = -fastCycle * 0.4;
}

// Splashing
if (this.activity === 'splashing' || this.activity === 'playing_in_waves') {
  if (this.limbRefs.upperArmL) this.limbRefs.upperArmL.rotation.x = -0.8 + fastCycle * 0.5;
  if (this.limbRefs.upperArmR) this.limbRefs.upperArmR.rotation.x = -0.8 - fastCycle * 0.5;
  // Create splash particles
  if (Math.random() < 0.1 && particleSystem) {
    particleSystem.createSplash(this.position.x, 0, this.position.z, 0.5);
  }
}

// Jumping
if (this.activity === 'jumping' || this.activity === 'jumping_waves') {
  const jumpPhase = Math.abs(Math.sin(this.animPhase * 1.5));
  this.mesh.position.y = this.position.y + jumpPhase * 0.5;
  if (this.limbRefs.upperArmL) this.limbRefs.upperArmL.rotation.x = -1.2 - jumpPhase * 0.5;
  if (this.limbRefs.upperArmR) this.limbRefs.upperArmR.rotation.x = -1.2 - jumpPhase * 0.5;
}

// Waving
if (this.activity === 'waving') {
  if (this.limbRefs.upperArmR) this.limbRefs.upperArmR.rotation.x = -1.5;
  if (this.limbRefs.forearmR) this.limbRefs.forearmR.rotation.z = cycle * 0.4;
}

// Stretching
if (this.activity === 'stretching') {
  if (this.limbRefs.upperArmL) this.limbRefs.upperArmL.rotation.x = -2.5 + slowCycle * 0.3;
  if (this.limbRefs.upperArmR) this.limbRefs.upperArmR.rotation.x = -2.5 + slowCycle * 0.3;
  this.mesh.rotation.z = slowCycle * 0.1;
}

// Exercise animations
if (this.activity === 'doing_pushups') {
  const pushupPhase = Math.abs(Math.sin(this.animPhase * 0.8));
  this.mesh.position.y = this.position.y - 0.5 + pushupPhase * 0.15;
  if (this.limbRefs.upperArmL) this.limbRefs.upperArmL.rotation.x = -0.8 + pushupPhase * 0.4;
  if (this.limbRefs.upperArmR) this.limbRefs.upperArmR.rotation.x = -0.8 + pushupPhase * 0.4;
}

if (this.activity === 'doing_situps') {
  const situpPhase = Math.sin(this.animPhase * 0.6);
  this.mesh.rotation.x = -0.8 + situpPhase * 0.6;
}

// Sandcastle building animation
if (this.activity === 'building_sandcastle' || this.activity === 'digging_sand' || this.activity === 'building_moat') {
  this.buildingProgress += deltaTime * 0.3;
  
  if (this.buildingState === 0) {
    // Gathering sand
    if (this.limbRefs.upperArmR) {
      this.limbRefs.upperArmR.rotation.x = -0.8 + cycle * 0.3;
      this.limbRefs.upperArmR.rotation.z = -0.5;
    }
    if (this.bucketSand) this.bucketSand.visible = false;
    if (this.buildingProgress > 2) {
      this.buildingState = 1;
      this.buildingProgress = 0;
      if (this.bucketSand) this.bucketSand.visible = true;
    }
  } else if (this.buildingState === 1) {
    // Placing
    if (this.limbRefs.upperArmR) {
      this.limbRefs.upperArmR.rotation.x = -0.3 + cycle * 0.2;
    }
    if (this.bucket) {
      this.bucket.position.y = 0.1 + Math.abs(cycle) * 0.15;
    }
    if (this.buildingProgress > 2) {
      this.buildingState = 2;
      this.buildingProgress = 0;
      if (this.castleTower) this.castleTower.scale.y = Math.min(1, this.castleTower.scale.y + 0.25);
      if (this.castleTop && this.castleTower && this.castleTower.scale.y >= 0.8) {
        this.castleTop.scale.y = Math.min(1, this.castleTop.scale.y + 0.3);
      }
    }
  } else {
    // Patting
    if (this.limbRefs.upperArmR) this.limbRefs.upperArmR.rotation.x = -0.5 + cycle * 0.15;
    if (this.limbRefs.upperArmL) this.limbRefs.upperArmL.rotation.x = -0.5 - cycle * 0.15;
    if (this.bucket) this.bucket.position.y = 0;
    if (this.bucketSand) this.bucketSand.visible = false;
    if (this.buildingProgress > 1.5) {
      this.buildingState = 0;
      this.buildingProgress = 0;
    }
  }
  
  if (this.mySandcastle) {
    this.mySandcastle.position.set(this.position.x + 0.5, -0.55, this.position.z + 0.4);
  }
}

// Yoga/meditation gentle movement
if (this.activity === 'yoga_pose' || this.activity === 'meditating') {
  this.mesh.position.y = this.position.y + Math.sin(this.time * 0.5) * 0.02;
}

// Talking/laughing
if (this.activity === 'talking' || this.activity === 'laughing') {
  if (this.limbRefs.upperArmL) this.limbRefs.upperArmL.rotation.x = 0.2 + cycle * 0.15;
  if (this.limbRefs.upperArmR) this.limbRefs.upperArmR.rotation.x = 0.3 - cycle * 0.15;
  if (this.activity === 'laughing') {
    this.mesh.rotation.x = Math.sin(this.animPhase * 3) * 0.05;
  }
}

// Floating in water
if (this.activity === 'floating') {
  this.mesh.position.y = this.position.y + Math.sin(this.time) * 0.1;
  this.position.x += Math.sin(this.time * 0.3) * 0.01;
}

// Update height based on location
let baseY = 0;
if (this.position.z < -15) {
  // On beach
  baseY = -0.5;
} else {
  // In water - bob with waves
  const waveHeight = (ocean && ocean.getHeightAt) ? ocean.getHeightAt(this.position.x, this.position.z) : 0;
  baseY = waveHeight - 0.3 + Math.sin(this.time) * 0.1;
  
  // Create ripples when moving in water
  if (isMoving && particleSystem && Math.random() < 0.05) {
    particleSystem.createSplash(this.position.x, waveHeight, this.position.z, 0.2);
  }
}

// Don't override Y for lying poses or jumping
const lyingActivities = ['lying_back', 'lying_front', 'lying_side', 'making_sand_angel', 'floating', 'swimming', 'swimming_backstroke', 'swimming_breaststroke', 'snorkeling', 'bodyboarding', 'doggy_paddle'];
const jumpingActivities = ['jumping', 'jumping_waves', 'doing_pushups'];

if (!lyingActivities.includes(this.activity) && !jumpingActivities.includes(this.activity)) {
  this.position.y = baseY;
  this.mesh.position.y = baseY;
}

this.mesh.position.x = this.position.x;
this.mesh.position.z = this.position.z;
}

remove() {
scene.remove(this.mesh);
if (this.mySandcastle) {
  scene.remove(this.mySandcastle);
  this.mySandcastle.traverse(child => {
    if (child.geometry) child.geometry.dispose();
    if (child.material) child.material.dispose();
  });
}
this.mesh.traverse(child => {
  if (child.geometry) child.geometry.dispose();
  if (child.material) child.material.dispose();
});
}
}

// Beach objects (towels, umbrellas, etc.)
let beachTowels = [];
let beachUmbrellas = [];
let sandcastles = [];
let beachBalls = [];

function createBeachItems() {
console.log('Creating beach items...');

// Beach towels
const towelColors = [0xff6b6b, 0x4ecdc4, 0xf9ca24, 0x45b7d1, 0x9b59b6, 0x2ecc71, 0xff8c42, 0x3498db];
for (let i = 0; i < 12; i++) {
  const towelGeo = new THREE.BoxGeometry(1.2, 0.02, 2);
  const towelMat = new THREE.MeshStandardMaterial({ 
    color: towelColors[Math.floor(Math.random() * towelColors.length)],
    roughness: 0.9
  });
  const towel = new THREE.Mesh(towelGeo, towelMat);
  towel.position.set(
    (Math.random() - 0.5) * 80,
    -0.48,
    -35 - Math.random() * 20
  );
  towel.rotation.y = Math.random() * Math.PI;
  towel.receiveShadow = true;
  scene.add(towel);
  beachTowels.push(towel);
}

// Beach umbrellas
for (let i = 0; i < 8; i++) {
  const umbrellaGroup = new THREE.Group();
  
  // Pole
  const poleGeo = new THREE.CylinderGeometry(0.05, 0.05, 3, 8);
  const poleMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness: 0.5 });
  const pole = new THREE.Mesh(poleGeo, poleMat);
  pole.position.y = 1.5;
  pole.castShadow = true;
  umbrellaGroup.add(pole);
  
  // Canopy
  const canopyGeo = new THREE.ConeGeometry(1.8, 0.8, 16, 1, true);
  const canopyMat = new THREE.MeshStandardMaterial({ 
    color: towelColors[Math.floor(Math.random() * towelColors.length)],
    side: THREE.DoubleSide,
    roughness: 0.8
  });
  const canopy = new THREE.Mesh(canopyGeo, canopyMat);
  canopy.position.y = 2.8;
  canopy.rotation.x = Math.PI;
  canopy.castShadow = true;
  umbrellaGroup.add(canopy);
  
  umbrellaGroup.position.set(
    (Math.random() - 0.5) * 70,
    -0.5,
    -38 - Math.random() * 15
  );
  scene.add(umbrellaGroup);
  beachUmbrellas.push(umbrellaGroup);
}

// Sandcastles
for (let i = 0; i < 5; i++) {
  const castleGroup = new THREE.Group();
  const sandMat = new THREE.MeshStandardMaterial({ color: 0xd4b896, roughness: 0.95 });
  
  // Main tower
  const towerGeo = new THREE.CylinderGeometry(0.3, 0.4, 0.6, 12);
  const tower = new THREE.Mesh(towerGeo, sandMat);
  tower.position.y = 0.3;
  tower.castShadow = true;
  castleGroup.add(tower);
  
  // Tower top
  const topGeo = new THREE.ConeGeometry(0.35, 0.3, 12);
  const top = new THREE.Mesh(topGeo, sandMat);
  top.position.y = 0.7;
  top.castShadow = true;
  castleGroup.add(top);
  
  // Small towers
  for (let j = 0; j < 4; j++) {
    const angle = (j / 4) * Math.PI * 2;
    const smallTowerGeo = new THREE.CylinderGeometry(0.15, 0.2, 0.4, 10);
    const smallTower = new THREE.Mesh(smallTowerGeo, sandMat);
    smallTower.position.set(Math.cos(angle) * 0.5, 0.2, Math.sin(angle) * 0.5);
    smallTower.castShadow = true;
    castleGroup.add(smallTower);
    
    const smallTopGeo = new THREE.ConeGeometry(0.18, 0.2, 10);
    const smallTop = new THREE.Mesh(smallTopGeo, sandMat);
    smallTop.position.set(Math.cos(angle) * 0.5, 0.5, Math.sin(angle) * 0.5);
    smallTop.castShadow = true;
    castleGroup.add(smallTop);
  }
  
  castleGroup.position.set(
    (Math.random() - 0.5) * 60,
    -0.5,
    -32 - Math.random() * 10
  );
  castleGroup.scale.setScalar(0.8 + Math.random() * 0.4);
  scene.add(castleGroup);
  sandcastles.push(castleGroup);
}

// Beach balls
for (let i = 0; i < 6; i++) {
  const ballGeo = new THREE.SphereGeometry(0.25, 20, 16);
  const ballMat = new THREE.MeshStandardMaterial({ 
    color: [0xff0000, 0x0000ff, 0xffff00, 0x00ff00][Math.floor(Math.random() * 4)],
    roughness: 0.3
  });
  const ball = new THREE.Mesh(ballGeo, ballMat);
  ball.position.set(
    (Math.random() - 0.5) * 80,
    -0.25,
    -25 - Math.random() * 25
  );
  ball.castShadow = true;
  ball.userData.velocity = new THREE.Vector3(
    (Math.random() - 0.5) * 0.5,
    0,
    (Math.random() - 0.5) * 0.5
  );
  scene.add(ball);
  beachBalls.push(ball);
}

console.log('Beach items created ‚úì');
}

function updateBeachBalls(deltaTime) {
beachBalls.forEach(ball => {
  // Simple bouncing physics
  ball.position.add(ball.userData.velocity.clone().multiplyScalar(deltaTime));
  
  // Bounce off boundaries
  if (Math.abs(ball.position.x) > 40) {
    ball.userData.velocity.x *= -0.9;
    ball.position.x = Math.sign(ball.position.x) * 40;
  }
  if (ball.position.z > -20 || ball.position.z < -50) {
    ball.userData.velocity.z *= -0.9;
    ball.position.z = Math.max(-50, Math.min(-20, ball.position.z));
  }
  
  // Slow down
  ball.userData.velocity.multiplyScalar(0.995);
  
  // Rotate
  ball.rotation.x += ball.userData.velocity.z * 2;
  ball.rotation.z -= ball.userData.velocity.x * 2;
});
}

function updatePeople() {
// Mix of water and beach people
while (people.length < CONFIG.peopleCount) {
  const isBeachPerson = Math.random() < 0.4;
  let x, z, activity;
  
  if (isBeachPerson) {
    x = (Math.random() - 0.5) * 80;
    z = -35 - Math.random() * 18;
    activity = Math.random() < 0.5 ? 'sitting' : (Math.random() < 0.5 ? 'lying' : 'standing');
  } else {
    x = (Math.random() - 0.5) * 100;
    z = (Math.random() - 0.3) * 60;
    activity = Math.random() < 0.7 ? 'walking' : 'standing';
  }
  
  people.push(new HighPolyPerson(new THREE.Vector3(x, 0, z), { activity }));
}

while (people.length > CONFIG.peopleCount) {
  const person = people.pop();
  person.remove();
}

document.getElementById('peopleCount').textContent = people.length;
}

// ==========================================
// PARTICLE SYSTEM (SPLASHES)
// ==========================================

class SplashParticleSystem {
constructor() {
this.particles = [];

const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(1000 * 3);
const colors = new Float32Array(1000 * 3);

geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

const material = new THREE.PointsMaterial({
size: 0.12,
transparent: true,
opacity: 0.8,
vertexColors: true,
blending: THREE.AdditiveBlending,
depthWrite: false
});

this.points = new THREE.Points(geometry, material);
scene.add(this.points);
}

emit(position, count = 10) {
if (!CONFIG.showSplashes) return;

for (let i = 0; i < count && this.particles.length < 1000; i++) {
this.particles.push({
position: position.clone().add(new THREE.Vector3(
(Math.random() - 0.5) * 2,
Math.random(),
(Math.random() - 0.5) * 2
)),
velocity: new THREE.Vector3(
(Math.random() - 0.5) * 3,
Math.random() * 2 + 1,
(Math.random() - 0.5) * 3
),
life: 2000
});
}
}

// Create splash at specific location with intensity
createSplash(x, y, z, intensity = 1) {
if (!CONFIG.showSplashes) return;

const count = Math.floor(5 * intensity + Math.random() * 5 * intensity);
for (let i = 0; i < count && this.particles.length < 1000; i++) {
  const angle = Math.random() * Math.PI * 2;
  const speed = (0.5 + Math.random() * 1.5) * intensity;
  
  this.particles.push({
    position: new THREE.Vector3(
      x + (Math.random() - 0.5) * 0.5,
      y + Math.random() * 0.3,
      z + (Math.random() - 0.5) * 0.5
    ),
    velocity: new THREE.Vector3(
      Math.cos(angle) * speed,
      (1 + Math.random() * 2) * intensity,
      Math.sin(angle) * speed
    ),
    life: 1000 + Math.random() * 1000
  });
}
}

// Create ripple effect (more subtle)
createRipple(x, y, z) {
if (!CONFIG.showSplashes) return;

for (let i = 0; i < 3 && this.particles.length < 1000; i++) {
  const angle = Math.random() * Math.PI * 2;
  this.particles.push({
    position: new THREE.Vector3(x, y + 0.05, z),
    velocity: new THREE.Vector3(
      Math.cos(angle) * 0.3,
      0.2,
      Math.sin(angle) * 0.3
    ),
    life: 500 + Math.random() * 300
  });
}
}

update(deltaTime) {
const positions = this.points.geometry.attributes.position.array;
const colors = this.points.geometry.attributes.color.array;
let activeCount = 0;

for (let i = this.particles.length - 1; i >= 0; i--) {
const p = this.particles[i];

p.velocity.y += -9.8 * deltaTime * 0.5;
p.position.add(p.velocity.clone().multiplyScalar(deltaTime));
p.life -= deltaTime * 1000;

if (p.life <= 0 || p.position.y < -2) {
this.particles.splice(i, 1);
continue;
}

const idx = activeCount * 3;
positions[idx] = p.position.x;
positions[idx + 1] = p.position.y;
positions[idx + 2] = p.position.z;

colors[idx] = 0.5;
colors[idx + 1] = 0.8;
colors[idx + 2] = 1;

activeCount++;
}

this.points.geometry.setDrawRange(0, activeCount);
this.points.geometry.attributes.position.needsUpdate = true;
this.points.geometry.attributes.color.needsUpdate = true;

document.getElementById('particleCount').textContent = activeCount;
}
}

// ==========================================
// BIRDS
// ==========================================

class BirdsSystem {
constructor() {
this.birds = [];
const count = 5;
for (let i = 0; i < count; i++) {
const group = new THREE.Group();
const bodyGeo = new THREE.SphereGeometry(0.15, 6, 6);
const bodyMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
const body = new THREE.Mesh(bodyGeo, bodyMat);
group.add(body);
const wingGeo = new THREE.SphereGeometry(0.08, 4, 4);
const wing = new THREE.Mesh(wingGeo, bodyMat);
wing.scale.set(2, 0.5, 1);
wing.position.x = 0.1;
group.add(wing);
group.position.set(
(Math.random() - 0.5) * 120,
25 + Math.random() * 40,
(Math.random() - 0.5) * 80
);
group.userData = {
phase: Math.random() * Math.PI * 2,
speed: 0.3 + Math.random() * 0.4,
radius: 40 + Math.random() * 30,
centerX: (Math.random() - 0.5) * 60,
centerZ: (Math.random() - 0.5) * 40,
wingPhase: Math.random() * Math.PI * 2
};
scene.add(group);
this.birds.push(group);
}
}

update(deltaTime) {
this.birds.forEach(b => {
const u = b.userData;
u.phase += u.speed * deltaTime;
b.position.x = u.centerX + Math.cos(u.phase) * u.radius;
b.position.z = u.centerZ + Math.sin(u.phase) * u.radius;
b.position.y = 25 + Math.sin(u.phase * 0.7) * 15;
b.rotation.y = -u.phase;
u.wingPhase += 15 * deltaTime;
b.children[1].scale.x = 2 + Math.sin(u.wingPhase) * 0.5;
});
}
}

// ==========================================
// MODE SWITCHING
// ==========================================

function switchRenderMode() {
const mode = document.getElementById('renderMode').value;
console.log('Switching to mode:', mode);

if (ocean) ocean.remove();

if (mode === 'particle') {
ocean = new ParticleWaterSystem();
document.getElementById('currentMode').textContent = 'PARTICLE';
document.getElementById('waterType').textContent = '250k Points';
} else {
ocean = new MeshWaterSystem();
document.getElementById('currentMode').textContent = 'ULTRA';
document.getElementById('waterType').textContent = 'Mesh';
}

CONFIG.renderMode = mode;
showNotification(`Switched to ${mode.toUpperCase()} mode!`);
}

// ==========================================
// UI FUNCTIONS
// ==========================================

function updateWaveIntensity(val) {
CONFIG.waveIntensity = parseFloat(val);
document.getElementById('waveIntensityVal').textContent = val;
}

function updateWaveSpeed(val) {
CONFIG.waveSpeed = parseFloat(val);
document.getElementById('waveSpeedVal').textContent = val + 'x';
}

function updatePeopleCount(val) {
CONFIG.peopleCount = parseInt(val);
document.getElementById('peopleCountVal').textContent = val;
updatePeople();
}

function updateTimeOfDay(val) {
CONFIG.timeOfDay = parseFloat(val);
const labels = ['Midnight', 'Dawn', 'Morning', 'Noon', 'Afternoon', 'Sunset', 'Night'];
const idx = Math.min(6, Math.floor(val / 4));
document.getElementById('timeVal').textContent = labels[idx] || 'Night';
updateTimeOfDayLighting();
}

function updateSunIntensity(val) {
CONFIG.sunIntensity = parseFloat(val);
document.getElementById('sunVal').textContent = val;
updateTimeOfDayLighting();
}

function toggleAnimation(checked) {
CONFIG.animatePeople = checked;
}

function toggleSplashes(checked) {
CONFIG.showSplashes = checked;
}

function togglePanel() {
document.getElementById('control-panel').classList.toggle('collapsed');
}

// ==========================================
// ACTIONS
// ==========================================

function createBigWave() {
for (let i = 0; i < 50; i++) {
setTimeout(() => {
const angle = (i / 50) * Math.PI * 2;
const x = Math.cos(angle) * 30;
const z = Math.sin(angle) * 30;
ocean.disturb(x, z, -5);
if (particleSystem) particleSystem.emit(new THREE.Vector3(x, 0, z), 5);
}, i * 30);
}
showNotification('üåä Big wave generated!');
}

function addPerson() {
if (CONFIG.peopleCount >= 20) return;
CONFIG.peopleCount++;
document.getElementById('peopleSlider').value = CONFIG.peopleCount;
updatePeople();
showNotification('‚ûï Person added!');
}

function resetScene() {
CONFIG.waveIntensity = 1.2;
CONFIG.waveSpeed = 1.0;
CONFIG.peopleCount = 8;

document.getElementById('waveIntensity').value = 1.2;
document.getElementById('waveSpeed').value = 1.0;
document.getElementById('peopleSlider').value = 8;

updatePeople();
showNotification('‚Üª Scene reset!');
}

function randomizeScene() {
CONFIG.waveIntensity = 0.5 + Math.random() * 2;
CONFIG.waveSpeed = 0.5 + Math.random() * 2;

document.getElementById('waveIntensity').value = CONFIG.waveIntensity;
document.getElementById('waveSpeed').value = CONFIG.waveSpeed;

updateWaveIntensity(CONFIG.waveIntensity);
updateWaveSpeed(CONFIG.waveSpeed);

showNotification('üé≤ Scene randomized!');
}

function loadPreset(preset) {
const presets = {
morning: { time: 7, intensity: 0.8, speed: 0.7, sun: 1.2 },
noon: { time: 12, intensity: 1.2, speed: 1.0, sun: 1.5 },
sunset: { time: 18, intensity: 1.0, speed: 0.8, sun: 1.3 },
storm: { time: 15, intensity: 2.5, speed: 2.0, sun: 0.8 }
};

const p = presets[preset];
CONFIG.timeOfDay = p.time;
CONFIG.waveIntensity = p.intensity;
CONFIG.waveSpeed = p.speed;
CONFIG.sunIntensity = p.sun;

document.getElementById('timeOfDay').value = p.time;
document.getElementById('waveIntensity').value = p.intensity;
document.getElementById('waveSpeed').value = p.speed;
document.getElementById('sunIntensity').value = p.sun;

updateWaveIntensity(p.intensity);
updateWaveSpeed(p.speed);
updateSunIntensity(p.sun);
updateTimeOfDay(p.time);

showNotification(`üé¨ ${preset.toUpperCase()} preset loaded!`);
}

function addPersonAt() {
addPerson();
hideContextMenu();
}

function createWaveAt() {
createBigWave();
hideContextMenu();
}

function spawnBeachBall() {
showNotification('üèê Beach ball spawned!');
hideContextMenu();
}

// ==========================================
// PHYSICS SANDBOX
// ==========================================

function updateObjectWeight(val) {
CONFIG.objectWeight = parseFloat(val);
document.getElementById('weightVal').textContent = val;
}

function updateObjectScale(val) {
CONFIG.objectScale = parseFloat(val);
document.getElementById('scaleVal').textContent = val;
}

function updateModelScale(val) {
CONFIG.modelScale = parseFloat(val);
document.getElementById('modelScaleVal').textContent = val;
if (importedModel) {
  importedModel.scale.setScalar(parseFloat(val));
}
}

function updateModelWeight(val) {
CONFIG.modelWeight = parseFloat(val);
document.getElementById('modelWeightVal').textContent = val;
}

function dropBox() {
const scale = CONFIG.objectScale;
const weight = CONFIG.objectWeight;

const boxGeo = new THREE.BoxGeometry(1 * scale, 1 * scale, 1 * scale);
const boxMat = new THREE.MeshStandardMaterial({ 
  color: Math.random() * 0xffffff,
  roughness: 0.5,
  metalness: 0.1
});
const box = new THREE.Mesh(boxGeo, boxMat);

// Start above scene
box.position.set(
  (Math.random() - 0.5) * 40,
  20 + Math.random() * 10,
  (Math.random() - 0.5) * 40
);
box.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
box.castShadow = true;
box.receiveShadow = true;

// Physics data
box.userData.velocity = new THREE.Vector3(0, 0, 0);
box.userData.angularVelocity = new THREE.Vector3(
  (Math.random() - 0.5) * 2,
  (Math.random() - 0.5) * 2,
  (Math.random() - 0.5) * 2
);
box.userData.weight = weight;
box.userData.type = 'box';

scene.add(box);
physicsObjects.push(box);
showNotification('üì¶ Box dropped!');
}

function dropSphere() {
const scale = CONFIG.objectScale;
const weight = CONFIG.objectWeight;

const sphereGeo = new THREE.SphereGeometry(0.5 * scale, 16, 12);
const sphereMat = new THREE.MeshStandardMaterial({ 
  color: Math.random() * 0xffffff,
  roughness: 0.3,
  metalness: 0.2
});
const sphere = new THREE.Mesh(sphereGeo, sphereMat);

sphere.position.set(
  (Math.random() - 0.5) * 40,
  20 + Math.random() * 10,
  (Math.random() - 0.5) * 40
);
sphere.castShadow = true;
sphere.receiveShadow = true;

sphere.userData.velocity = new THREE.Vector3(0, 0, 0);
sphere.userData.angularVelocity = new THREE.Vector3(
  (Math.random() - 0.5) * 3,
  (Math.random() - 0.5) * 3,
  (Math.random() - 0.5) * 3
);
sphere.userData.weight = weight;
sphere.userData.type = 'sphere';

scene.add(sphere);
physicsObjects.push(sphere);
showNotification('‚öΩ Sphere dropped!');
}

function clearPhysicsObjects() {
physicsObjects.forEach(obj => {
  scene.remove(obj);
  if (obj.geometry) obj.geometry.dispose();
  if (obj.material) obj.material.dispose();
});
physicsObjects = [];
showNotification('üóëÔ∏è Objects cleared!');
}

function updatePhysicsObjects(deltaTime) {
const gravity = -9.8;
const groundLevel = -0.5; // Beach level
const waterLevel = 0;
const damping = 0.98;
const bounceFactor = 0.5;

physicsObjects.forEach(obj => {
  const v = obj.userData.velocity;
  const w = obj.userData.weight || 1;
  const av = obj.userData.angularVelocity;
  const wasInWater = obj.userData.wasInWater || false;
  
  // Apply gravity (heavier = faster fall)
  v.y += gravity * w * deltaTime;
  
  // Store previous Y for splash detection
  const prevY = obj.position.y;
  
  // Update position
  obj.position.add(v.clone().multiplyScalar(deltaTime));
  
  // Update rotation
  obj.rotation.x += av.x * deltaTime;
  obj.rotation.y += av.y * deltaTime;
  obj.rotation.z += av.z * deltaTime;
  
  // Ground collision
  const objRadius = obj.userData.type === 'sphere' ? 0.5 * CONFIG.objectScale : 0.5 * CONFIG.objectScale;
  const objScale = obj.userData.type === 'model' ? CONFIG.modelScale : CONFIG.objectScale;
  
  // Check if in water or on beach
  let floorLevel = groundLevel;
  const inWaterZone = obj.position.z > -15;
  
  if (inWaterZone && ocean) {
    const waveH = ocean.getHeightAt(obj.position.x, obj.position.z);
    floorLevel = waveH - objRadius * 0.3;
    
    // Check if object is touching water surface
    const touchingWater = obj.position.y < waveH + objRadius;
    
    if (touchingWater) {
      // Calculate impact velocity for splash intensity
      const impactSpeed = Math.abs(v.y);
      const splashIntensity = Math.min(2, impactSpeed * w * 0.2);
      
      // First time entering water - big splash!
      if (!wasInWater && impactSpeed > 1) {
        // Create splash based on weight and velocity
        if (particleSystem) {
          particleSystem.createSplash(obj.position.x, waveH, obj.position.z, splashIntensity * w);
        }
        // Create water disturbance ripples based on weight
        ocean.disturb(obj.position.x, obj.position.z, splashIntensity * w);
      }
      
      // Continuous water interaction while in water
      if (Math.random() < 0.15 * w) {
        // Heavier objects create more disturbance
        ocean.disturb(obj.position.x, obj.position.z, 0.2 * w);
        
        // Create small continuous splashes
        if (particleSystem && Math.random() < 0.3) {
          particleSystem.createRipple(obj.position.x, waveH, obj.position.z);
        }
      }
      
      // Water drag - heavier objects have more momentum
      const dragFactor = 0.92 + (w * 0.02); // Heavy objects less affected by drag
      v.multiplyScalar(Math.min(0.99, dragFactor));
      av.multiplyScalar(0.92);
      
      // Buoyancy (lighter objects float more, heavy objects sink)
      const buoyancyForce = (1 / w) * 4 - (w * 0.5);
      v.y += buoyancyForce * deltaTime;
      
      // Very heavy objects sink to bottom
      if (w > 3) {
        floorLevel = waveH - 2 - (w * 0.5);
      }
      
      obj.userData.wasInWater = true;
    } else {
      obj.userData.wasInWater = false;
    }
  } else {
    obj.userData.wasInWater = false;
  }
  
  if (obj.position.y - objRadius < floorLevel) {
    obj.position.y = floorLevel + objRadius;
    v.y *= -bounceFactor / w; // Heavy objects bounce less
    v.x *= damping;
    v.z *= damping;
    av.multiplyScalar(0.8);
  }
  
  // Keep in bounds
  if (Math.abs(obj.position.x) > 80) {
    obj.position.x = Math.sign(obj.position.x) * 80;
    v.x *= -0.5;
  }
  if (obj.position.z > 80 || obj.position.z < -60) {
    obj.position.z = Math.max(-60, Math.min(80, obj.position.z));
    v.z *= -0.5;
  }
});
}

// 3D Model Import
function handleModelImport(event) {
const file = event.target.files[0];
if (!file) return;

const filename = file.name.toLowerCase();
const url = URL.createObjectURL(file);

if (filename.endsWith('.glb') || filename.endsWith('.gltf')) {
  if (!gltfLoader) gltfLoader = new THREE.GLTFLoader();
  
  gltfLoader.load(url, (gltf) => {
    if (importedModel) {
      scene.remove(importedModel);
    }
    importedModel = gltf.scene;
    importedModel.scale.setScalar(CONFIG.modelScale);
    importedModel.position.set(0, 5, -30);
    importedModel.traverse(child => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;
      }
    });
    scene.add(importedModel);
    document.getElementById('importedModelControls').style.display = 'block';
    showNotification('üìÇ Model loaded: ' + file.name);
    URL.revokeObjectURL(url);
  }, undefined, (error) => {
    console.error('Error loading GLTF:', error);
    showNotification('‚ùå Failed to load model');
  });
} else if (filename.endsWith('.obj')) {
  if (!objLoader) objLoader = new THREE.OBJLoader();
  
  objLoader.load(url, (obj) => {
    if (importedModel) {
      scene.remove(importedModel);
    }
    importedModel = obj;
    importedModel.scale.setScalar(CONFIG.modelScale);
    importedModel.position.set(0, 5, -30);
    importedModel.traverse(child => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;
        if (!child.material.color) {
          child.material = new THREE.MeshStandardMaterial({ color: 0x888888 });
        }
      }
    });
    scene.add(importedModel);
    document.getElementById('importedModelControls').style.display = 'block';
    showNotification('üìÇ Model loaded: ' + file.name);
    URL.revokeObjectURL(url);
  }, undefined, (error) => {
    console.error('Error loading OBJ:', error);
    showNotification('‚ùå Failed to load model');
  });
} else {
  showNotification('‚ùå Unsupported format. Use GLB, GLTF, or OBJ');
}
}

function dropImportedModel() {
if (!importedModel) {
  showNotification('‚ùå No model loaded');
  return;
}

// Clone the model
const clone = importedModel.clone();
clone.position.set(
  (Math.random() - 0.5) * 40,
  20 + Math.random() * 10,
  (Math.random() - 0.5) * 40
);
clone.scale.setScalar(CONFIG.modelScale);

clone.userData.velocity = new THREE.Vector3(0, 0, 0);
clone.userData.angularVelocity = new THREE.Vector3(
  (Math.random() - 0.5) * 2,
  (Math.random() - 0.5) * 2,
  (Math.random() - 0.5) * 2
);
clone.userData.weight = CONFIG.modelWeight;
clone.userData.type = 'model';

scene.add(clone);
physicsObjects.push(clone);
showNotification('üì• Model dropped!');
}

// ==========================================
// CONTEXT MENU
// ==========================================

const contextMenu = document.getElementById('context-menu');

window.addEventListener('contextmenu', (e) => {
e.preventDefault();
contextMenu.style.display = 'block';
contextMenu.style.left = e.clientX + 'px';
contextMenu.style.top = e.clientY + 'px';
});

function hideContextMenu() {
contextMenu.style.display = 'none';
}

window.addEventListener('click', (e) => {
if (!e.target.closest('#context-menu')) hideContextMenu();
});

// ==========================================
// NOTIFICATIONS
// ==========================================

function showNotification(message) {
const notif = document.createElement('div');
notif.className = 'notification';
notif.textContent = message;
document.body.appendChild(notif);

setTimeout(() => {
notif.style.animation = 'notifSlide 0.3s ease reverse';
setTimeout(() => notif.remove(), 300);
}, 2500);
}

// ==========================================
// WINDOW RESIZE
// ==========================================

window.addEventListener('resize', () => {
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
});

// ==========================================
// ANIMATION LOOP
// ==========================================

let lastTime = performance.now();
let frames = 0;
let lastFpsUpdate = performance.now();

function animate() {
requestAnimationFrame(animate);

const currentTime = performance.now();
const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
lastTime = currentTime;

if (ocean) ocean.update(deltaTime);

// Update people and create water disturbances
people.forEach(person => {
  person.update(deltaTime);
  
  // Create water disturbances when people are in water and moving
  if (person.position.z > -15 && ocean) {
    const isMoving = ['swimming', 'swimming_backstroke', 'swimming_breaststroke', 'doggy_paddle', 
      'splashing', 'playing_in_waves', 'jumping_waves', 'wading', 'walking_in_water', 'treading_water']
      .includes(person.activity);
    
    if (isMoving && Math.random() < 0.1) {
      ocean.disturb(person.position.x, person.position.z, 0.3);
    }
  }
});

if (particleSystem) particleSystem.update(deltaTime);
if (birdsSystem) birdsSystem.update(deltaTime);
updateBeachBalls(deltaTime);
updatePhysicsObjects(deltaTime);

updateTimeOfDayLighting();

updateCameraMovement();
controls.update();
renderer.render(scene, camera);

frames++;
if (currentTime - lastFpsUpdate >= 1000) {
document.getElementById('fps').textContent = frames;
frames = 0;
lastFpsUpdate = currentTime;
}
}

// ==========================================
// INITIALIZATION
// ==========================================

const LOADING_TIPS = [
'Use WASD keys to move around and explore!',
'Press Q to go up, E to go down.',
'Try the Sunset preset for golden hour lighting.',
'Right-click anywhere to add people or create waves.',
'Drop boxes and spheres from the Physics Sandbox!',
'Watch people walk around and build sandcastles.',
'Import your own 3D models (GLB/OBJ) and drop them!',
'Heavy objects sink, light ones float in water.'
];

async function startLoading() {
console.log('üèñÔ∏è Starting OceanLife Pro...');

const progress = document.getElementById('progress');
const status = document.getElementById('load-status');
const tipEl = document.getElementById('loading-tip');

// Show random tip
if (tipEl) tipEl.textContent = LOADING_TIPS[Math.floor(Math.random() * LOADING_TIPS.length)];

// Helper to update progress with delay for visual feedback
const updateProgress = (percent, message, delay = 200) => {
  return new Promise(resolve => {
    progress.style.width = percent + '%';
    status.textContent = message;
    setTimeout(resolve, delay);
  });
};

try {
  // Step 1: Initialize scene
  await updateProgress(10, 'Initializing 3D engine...', 300);
  initScene();
  await updateProgress(20, 'Scene created ‚úì', 200);
  
  // Step 2: Setup lighting
  await updateProgress(25, 'Setting up lighting...', 200);
  setupLighting();
  await updateProgress(35, 'Lighting ready ‚úì', 200);
  
  // Step 3: Create beach
  await updateProgress(40, 'Generating beach terrain...', 300);
  createBeach();
  await updateProgress(50, 'Beach created ‚úì', 200);
  
  // Step 4: Beach items
  await updateProgress(55, 'Adding beach objects...', 300);
  createBeachItems();
  await updateProgress(65, 'Towels, umbrellas placed ‚úì', 200);
  
  // Step 5: Water system
  await updateProgress(70, 'Creating water simulation...', 400);
  ocean = new MeshWaterSystem();
  await updateProgress(80, 'Water system ready ‚úì', 200);
  
  // Step 6: Particle system
  await updateProgress(82, 'Initializing particle effects...', 200);
  particleSystem = new SplashParticleSystem();
  await updateProgress(85, 'Particles ready ‚úì', 150);
  
  // Step 7: Birds
  await updateProgress(88, 'Adding wildlife...', 200);
  birdsSystem = new BirdsSystem();
  await updateProgress(92, 'Birds added ‚úì', 150);
  
  // Step 8: People
  await updateProgress(95, 'Spawning beachgoers...', 300);
  updatePeople();
  await updateProgress(100, 'All ready!', 300);
  
  // Fade out loading screen
  status.textContent = 'üèñÔ∏è Welcome to OceanLife Pro!';
  await new Promise(resolve => setTimeout(resolve, 500));
  
  document.getElementById('loading-screen').style.opacity = '0';
  
  await new Promise(resolve => setTimeout(resolve, 800));
  
  document.getElementById('loading-screen').style.display = 'none';
  animate();
  showNotification('üèñÔ∏è Welcome to OceanLife Pro v1.0!');
  console.log('‚úì OceanLife Pro ready!');
  
} catch (error) {
  console.error('Loading error:', error);
  status.textContent = '‚ùå Error loading: ' + error.message;
  progress.style.backgroundColor = '#ff4444';
}
}

function init() {
startLoading();
}

// Start when DOM is ready
if (document.readyState === 'loading') {
document.addEventListener('DOMContentLoaded', init);
} else {
init();
}

</script>
</body>
</html>